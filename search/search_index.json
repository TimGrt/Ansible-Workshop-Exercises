{"config":{"lang":["en"],"separator":"[\\s]","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the Ansible Workshop!","text":"<p>Ansible is a radically simple IT automation system. It handles configuration management, application deployment, cloud provisioning, ad-hoc task execution, network automation, and multi-node orchestration.</p> <p> </p> <p>You will learn all about Ansible:</p> <ol> <li>starting with the basics of understanding foundational command line activities</li> <li>applying what you\u2019ve learned to implement Ansible automation controller to your enterprise use cases.</li> <li>learn about the Ansible future and network automation</li> </ol> <p>You\u2019ll start off by writing your first Ansible playbook, work on Jinja templates, and implement higher-level Ansible roles. Next you\u2019ll get started on automation controller, understand inventory and credential management, projects, job templates, surveys, workflows and more.</p> <p>After finishing this lab you are ready to start using Ansible for your automation requirements.</p>"},{"location":"#time-planning","title":"Time planning","text":"<p>The time required to do the workshops strongly depends on multiple factors: the length of the workshop. the number of participants, how familiar you are with Linux in general and how much discussions are done in between.</p> <p>Having said that, the exercises themselves should take roughly 4-5 hours, not counting the projects.  </p>"},{"location":"#lab-overview","title":"Lab Overview","text":""},{"location":"ansible-basics-overview/","title":"Overview","text":"<p>The first workshop day is all about getting to know Ansible and learning to write your first Ansible Playbooks.  </p> <p> </p> <p>You will complete the following exercises today:</p> <ul> <li>Exercise 1 - Check the Prerequisites</li> <li>Exercise 2 - The Ansible Basics</li> <li>Exercise 3 - Writing your first Playbook</li> <li>Exercise 4 - Using Variables</li> <li>Exercise 5 - Work with conditionals</li> <li>Exercise 6 - Run tasks multiple times</li> <li>Exercise 7 - Trigger changes with Handlers</li> <li>Exercise 8 - Templating with Jinja2</li> <li>Exercise 9 - Reusability with Roles</li> </ul>"},{"location":"ansible-future-overview/","title":"Overview","text":"<p>This section shows tools in the Ansible world which will become more and more relevant in the upcoming future. This includes:</p> <ul> <li>Ansible Navigator</li> <li>Execution Environments</li> <li>Ansible Builder</li> </ul> <p> </p>"},{"location":"ansible-future-overview/#who-will-use-the-ansible-navigator","title":"Who will use the Ansible navigator?","text":"<p>The automation content navigator (or \"Ansible Navigator\") is mainly geared towards developers of automation. This can mean people creating automated tasks with available modules, those migrating roles into Collections or those who are developing modules from the ground up. Content navigator runs as a textual user interface and looks great within a terminal session, even while running inside popular code editors with included terminal panes.</p>"},{"location":"ansible-future-overview/#who-will-use-execution-environments","title":"Who will use Execution Environments?","text":"<p>Everybody will use Execution environments, not only will they become more relevant for users of Ansible Core, but they are integral to users of the Ansible Automation platform (even if they don't know that they are using EEs). In short, Execution Environments are Container images which run the automation tasks, think about them as an Ansible Control node in a Container. They are a defined, consistent and portable environment for Ansible Automation consisting of a RHEL Universal Base Image, Ansible Core, Python 3, Ansible Content Collections and all dependencies.</p>"},{"location":"ansible-future-overview/#who-will-use-the-ansible-builder","title":"Who will use the Ansible Builder?","text":"<p>Ansible Builder is a tool that aids in the creation of Ansible Execution Environments, no container know-how is necessary, a simple YAML configuration file is used to create the Podman or Docker image. The Ansible builder will be used by Automation developers and Automation platform administrators.</p>"},{"location":"automation-platform-overview/","title":"Overview","text":"<p>Day 2 of the Ansible Workshop is all about the Ansible Automation Platform and usage of the Ansible Automation Controller.</p> <p> </p> <p>You will complete the following exercises today:</p> <ul> <li>Exercise 1 - Introduction</li> <li>Exercise 2 - Inventories, credentials and ad hoc commands</li> <li>Exercise 3 - Projects &amp; Job Templates</li> <li>Exercise 4 - Surveys</li> <li>Exercise 5 - Role-based access control</li> <li>Exercise 6 - Workflows</li> <li>Exercise 7 - AAP Wrap up</li> </ul> <p>Here are some additional information of the the Ansible Automation Platform:</p>"},{"location":"automation-platform-overview/#whats-new-in-ansible-automation-controller-40","title":"What's New in Ansible automation controller 4.0","text":"<p>Ansible Automation Platform 2 is the next evolution in automation from Red Hat\u2019s trusted enterprise technology experts. The Ansible Automation Platform 2 release includes automation controller 4.0, the improved and renamed Ansible Tower.</p> <p>Controller continues to provide a standardized way to define, operate, and delegate automation across the enterprise. It introduces new technologies and an enhanced architecture that enables automation teams to scale and deliver automation rapidly.</p>"},{"location":"automation-platform-overview/#why-was-ansible-tower-renamed-to-automation-controller","title":"Why was Ansible Tower renamed to automation controller?","text":"<p>As Ansible Automation Platform 2 continues to evolve, certain functionality has been decoupled (and will continue to be decoupled in future releases) from what was formerly known as Ansible Tower. It made sense to introduce the naming change that better reflects these enhancements and the overall position within the Ansible Automation Platform suite.</p>"},{"location":"automation-platform-overview/#who-is-automation-controller-for","title":"Who is automation controller for?","text":"<p>All automation team members interact with or rely on automation controller, either directly or indirectly.</p> <ul> <li>Automation creators develop Ansible playbooks, roles, and modules.</li> <li>Automation architects elevate automation across teams to align with IT processes and streamline adoption.</li> <li>Automation operators ensure the automation platform and framework are operational.</li> </ul> <p>These roles are not necessarily dedicated to a person or team. Many organizations assign multiple roles to people or outsource specific automation tasks based on their needs.</p> <p>Automation operators are typically the primary individuals who interact directly with the automation controller, based on their responsibilities.</p>"},{"location":"automation-platform-overview/#automation-mesh","title":"Automation mesh","text":"<p>Automation mesh is an overlay network intended to ease the distribution of work across a large and dispersed collection of workers. Mesh nodes establish peer-to-peer connections with each other across your existing networks bringing automation closer to the endpoints that need it.</p>"},{"location":"ansible-core/ansible-core-basics/","title":"2 - The Ansible Basics","text":""},{"location":"ansible-core/ansible-core-basics/#objective","title":"Objective","text":"<p>In this exercise, we are going to explore the Ansible command line utility <code>ansible-inventory</code> to learn how to work with inventory files, using the utility <code>ansible</code> to run commands on hosts in the inventory file and getting help by the <code>ansible-doc</code> utility. The goal is to familiarize yourself with some of the different cli tools Ansible provides and how it can be used to enrich your Ansible experience.</p> <p>This exercise will cover</p> <ul> <li>Working with inventory files</li> <li>Locating and understanding an <code>ini</code> formatted inventory file</li> <li>Running commands on inventory groups with Ansible Ad-Hoc commands</li> <li>Listing modules and getting help when trying to use them</li> </ul>"},{"location":"ansible-core/ansible-core-basics/#guide","title":"Guide","text":""},{"location":"ansible-core/ansible-core-basics/#step-1-check-the-infrastructure","title":"Step 1 - Check the infrastructure","text":"<p>The Ansible master nodes by default communicates via SSH with all managed hosts. As we are automating Linux hosts, this is fine and we need to make sure that we can reach every node with SSH. If you intend to automate hosts that can't be reached with the default method, e.g. Windows hosts, network infrastructure nodes, firewall hosts and so on, you need to instruct Ansible to use another communication method. In most cases, this is very easy and only requires setting a certain variable. But, let's focus on automating Linux nodes first.</p> <p>You can reach all your managed nodes (the hosts that you want to automate) with password-less SSH, you won't need to enter a password (or a user) when connecting to the nodes.</p> <p>Try it out, SSH to <code>node1</code>:</p> <pre><code>[student1@ansible-1 ~]$ ssh node1\n[ec2-user@node1 ~]$\n</code></pre> <p>As you can see, you are now the user <code>ec2-user</code> on <code>node1</code>. Leave <code>node1</code> again:</p> <pre><code>[ec-user@node1 ~]$ exit\n[student1@ansible-1 ~]$\n</code></pre> <p>You can also connect to <code>node2</code> and <code>node3</code> with the same method. When you are finished, make sure you are back on your Ansible Control node (<code>ansible-1</code>), only here you can execute Ansible commands (as the Ansible binary is only installed on the Controller, Ansible works agent-less).</p>"},{"location":"ansible-core/ansible-core-basics/#step-2-work-with-your-inventory","title":"Step 2 - Work with your Inventory","text":"<p>An inventory file is a text file that specifies the nodes that will be managed by the control machine. The nodes to be managed may include a list of hostnames and/or IP addresses of those nodes. The inventory file allows for nodes to be organized into groups by declaring a host group name within square brackets ([ ]).</p> <p>To use the <code>ansible-inventory</code> command for host management, you need to provide an inventory file which defines a list of hosts to be managed from the control node. In this lab, the inventory is provided by your instructor. The inventory file is an <code>ini</code> formatted file listing your hosts, sorted in groups, additionally providing some variables. It looks like:</p> <pre><code>[web]\nnode1 ansible_host=&lt;X.X.X.X&gt;\nnode2 ansible_host=&lt;Y.Y.Y.Y&gt;\nnode3 ansible_host=&lt;Z.Z.Z.Z&gt;\n\n[control]\nansible-1 ansible_host=44.55.66.77\n</code></pre> <p>Ansible is already configured to use the inventory specific to your environment. We will show you in the next step how that is done. For now, we will execute some simple commands to work with the inventory.</p> <p>To reference all the inventory hosts, you supply a pattern to the <code>ansible-inventory</code> command. The <code>--list</code> option can be useful for displaying all the hosts that are part of an inventory file including what groups they are associated with.</p> AnsibleNavigator <pre><code>[student@ansible-1 ~]$ ansible-inventory --list\n{\n    \"_meta\": {\n        \"hostvars\": {\n            \"ansible-1\": {\n                \"ansible_host\": \"3.236.186.92\"\n            },\n            \"node1\": {\n                \"ansible_host\": \"3.239.234.187\"\n            },\n            \"node2\": {\n                \"ansible_host\": \"75.101.228.151\"\n            },\n            \"node3\": {\n                \"ansible_host\": \"100.27.38.142\"\n            }\n        }\n    },\n    \"all\": {\n        \"children\": [\n            \"control\",\n            \"ungrouped\",\n            \"web\"\n        ]\n    },\n    \"control\": {\n        \"hosts\": [\n            \"ansible-1\"\n        ]\n    },\n    \"web\": {\n        \"hosts\": [\n            \"node1\",\n            \"node2\",\n            \"node3\"\n        ]\n    }\n}\n</code></pre> <pre><code>[student@ansible-1 ~]$ ansible-navigator inventory --list -m stdout\n{\n    \"_meta\": {\n        \"hostvars\": {\n            \"ansible-1\": {\n                \"ansible_connection\": \"local\"\n            },\n            \"node1\": {\n                \"ansible_host\": \"node1.example.com\"\n            },\n            \"node2\": {\n                \"ansible_host\": \"node2.example.com\"\n            },\n            \"node3\": {\n                \"ansible_host\": \"node3.example.com\"\n            }\n        }\n    },\n    \"all\": {\n        \"children\": [\n            \"control\",\n            \"ungrouped\",\n            \"web\"\n        ]\n    },\n    \"control\": {\n        \"hosts\": [\n            \"ansible-1\"\n        ]\n    },\n    \"web\": {\n        \"hosts\": [\n            \"node1\",\n            \"node2\",\n            \"node3\"\n        ]\n    }\n}\n</code></pre> <p>If <code>--list</code> is too verbose, the option of <code>--graph</code> can be used to provide a more condensed version of <code>--list</code>.</p> AnsibleNavigator <pre><code>[student1@ansible-1 ~]$ ansible-inventory --graph\n@all:\n|--@control:\n|  |--ansible-1\n|--@ungrouped:\n|--@web:\n|  |--node1\n|  |--node2\n|  |--node3\n</code></pre> <pre><code>[student1@ansible-1 ~]$ ansible-navigator inventory --graph -m stdout\n@all:\n|--@control:\n|  |--ansible-1\n|--@ungrouped:\n|--@web:\n|  |--node1\n|  |--node2\n|  |--node3\n</code></pre> <p>We can clearly see that nodes: <code>node1</code>, <code>node2</code>, <code>node3</code> are part of the <code>web</code> group, while <code>ansible-1</code> is part of the <code>control</code> group.</p> <p>An inventory file can contain a lot more information, it can organize your hosts in groups or define variables. In our example, the current inventory has the groups <code>web</code> and <code>control</code>.</p> <p>Using the <code>ansible-inventory</code> command, we can also run commands that provide information only for one host or group. For example, give the following commands a try to see their output.</p> AnsibleNavigator <pre><code>[student@ansible-1 ~]$ ansible-inventory --graph web\n[student@ansible-1 ~]$ ansible-inventory --graph control\n[student@ansible-1 ~]$ ansible-inventory --host node1\n</code></pre> <pre><code>[student@ansible-1 ~]$ ansible-navigator inventory --graph web -m stdout\n[student@ansible-1 ~]$ ansible-navigator inventory --graph control -m stdout\n[student@ansible-1 ~]$ ansible-navigator inventory --host node1 -m stdout\n</code></pre> <p>Tip</p> <p>The inventory can contain more data.</p>"},{"location":"ansible-core/ansible-core-basics/#step-3-use-the-inventory-with-ad-hoc-commands","title":"Step 3 - Use the inventory with ad-hoc commands","text":"<p>An Ansible ad hoc command uses the <code>ansible</code> command-line tool to automate a single task on one or more managed nodes. Ad hoc commands are quick and easy, but they are not reusable. So why learn about ad hoc commands first? Ad hoc commands demonstrate the simplicity and power of Ansible. The concepts you learn here will port over directly to the playbook language.</p> <p>Ad hoc commands are great for tasks you repeat rarely. For example, if you want to power off all the machines in your lab for Christmas vacation, you could execute a quick one-liner in Ansible without writing a playbook. An ad hoc command looks like this:</p> <pre><code>ansible [pattern] -m [module] -a \"[module options]\"\n</code></pre> <p>Ad hoc commands can be used perfectly to check if all hosts in your inventory are reachable. Ansible offers the ping module for that (this is not a real ICMP ping, though). Let's try to reach all hosts of the web group:</p> <pre><code>[student@ansible-1 ~]$ ansible web -m ping\nnode2 | SUCCESS =&gt; {\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/libexec/platform-python\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\nnode3 | SUCCESS =&gt; {\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/libexec/platform-python\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\nnode1 | SUCCESS =&gt; {\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/libexec/platform-python\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\n</code></pre> <p>Success! All three nodes are reachable, we get a pong back, we proved that we can establish a SSH connection and that the node(s) have a usable Python interpreter.</p> <p>Try to run the same ad hoc command against the control group.  </p> <pre><code>[student@ansible-1 ~]$ ansible control -m ping\nansible-1 | SUCCESS =&gt; {\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/libexec/platform-python\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\n</code></pre> <p>Let's play around with ad hoc commands a bit more. You can use every module that Ansible provides with ad hoc commands, we will learn more about modules later today. By default, Ansible will use the command module, you can send every linux command you want to all managed nodes, the arguments are provided with the <code>-a</code> parameter:</p> <pre><code>[student@ansible-1 ~]$ ansible web -m command -a \"cat /etc/os-release\"\nnode2 | CHANGED | rc=0 &gt;&gt;\nNAME=\"Red Hat Enterprise Linux\"\nVERSION=\"8.5 (Ootpa)\"\nID=\"rhel\"\nID_LIKE=\"fedora\"\nVERSION_ID=\"8.5\"\nPLATFORM_ID=\"platform:el8\"\nPRETTY_NAME=\"Red Hat Enterprise Linux 8.5 (Ootpa)\"\nANSI_COLOR=\"0;31\"\nCPE_NAME=\"cpe:/o:redhat:enterprise_linux:8::baseos\"\nHOME_URL=\"https://www.redhat.com/\"\nDOCUMENTATION_URL=\"https://access.redhat.com/documentation/red_hat_enterprise_linux/8/\"\nBUG_REPORT_URL=\"https://bugzilla.redhat.com/\"\n\nREDHAT_BUGZILLA_PRODUCT=\"Red Hat Enterprise Linux 8\"\nREDHAT_BUGZILLA_PRODUCT_VERSION=8.5\nREDHAT_SUPPORT_PRODUCT=\"Red Hat Enterprise Linux\"\nREDHAT_SUPPORT_PRODUCT_VERSION=\"8.5\"\nnode3 | CHANGED | rc=0 &gt;&gt;\nNAME=\"Red Hat Enterprise Linux\"\nVERSION=\"8.5 (Ootpa)\"\nID=\"rhel\"\nID_LIKE=\"fedora\"\nVERSION_ID=\"8.5\"\nPLATFORM_ID=\"platform:el8\"\nPRETTY_NAME=\"Red Hat Enterprise Linux 8.5 (Ootpa)\"\nANSI_COLOR=\"0;31\"\nCPE_NAME=\"cpe:/o:redhat:enterprise_linux:8::baseos\"\nHOME_URL=\"https://www.redhat.com/\"\nDOCUMENTATION_URL=\"https://access.redhat.com/documentation/red_hat_enterprise_linux/8/\"\nBUG_REPORT_URL=\"https://bugzilla.redhat.com/\"\n\nREDHAT_BUGZILLA_PRODUCT=\"Red Hat Enterprise Linux 8\"\nREDHAT_BUGZILLA_PRODUCT_VERSION=8.5\nREDHAT_SUPPORT_PRODUCT=\"Red Hat Enterprise Linux\"\nREDHAT_SUPPORT_PRODUCT_VERSION=\"8.5\"\nnode1 | CHANGED | rc=0 &gt;&gt;\nNAME=\"Red Hat Enterprise Linux\"\nVERSION=\"8.5 (Ootpa)\"\nID=\"rhel\"\nID_LIKE=\"fedora\"\nVERSION_ID=\"8.5\"\nPLATFORM_ID=\"platform:el8\"\nPRETTY_NAME=\"Red Hat Enterprise Linux 8.5 (Ootpa)\"\nANSI_COLOR=\"0;31\"\nCPE_NAME=\"cpe:/o:redhat:enterprise_linux:8::baseos\"\nHOME_URL=\"https://www.redhat.com/\"\nDOCUMENTATION_URL=\"https://access.redhat.com/documentation/red_hat_enterprise_linux/8/\"\nBUG_REPORT_URL=\"https://bugzilla.redhat.com/\"\n\nREDHAT_BUGZILLA_PRODUCT=\"Red Hat Enterprise Linux 8\"\nREDHAT_BUGZILLA_PRODUCT_VERSION=8.5\nREDHAT_SUPPORT_PRODUCT=\"Red Hat Enterprise Linux\"\nREDHAT_SUPPORT_PRODUCT_VERSION=\"8.5\"\n</code></pre> <p>You can shorten the command and leave out <code>-m command</code> as this module is used by default:</p> <pre><code>[student@ansible-1 ~]$ ansible control -a \"uname -a\"\nansible-1 | CHANGED | rc=0 &gt;&gt;\nLinux ansible-1.example.com 4.18.0-348.12.2.el8_5.x86_64 #1 SMP Mon Jan 17 07:06:06 EST 2022 x86_64 x86_64 x86_64 GNU/Linux\n</code></pre> <p>Ad hoc command are very useful to gather information about your managed nodes, the setup module is used. Try that against one host alone (so you won't get overwhelmed with output):</p> <pre><code>[student@ansible-1 ~]$ ansible node1 -m setup\nnode1 | SUCCESS =&gt; {\n    \"ansible_facts\": {\n        \"ansible_all_ipv4_addresses\": [\n            \"172.16.9.82\"\n        ],\n        \"ansible_all_ipv6_addresses\": [\n            \"fe80::a4:bff:fea5:6d70\"\n        ],\n        \"ansible_apparmor\": {\n            \"status\": \"disabled\"\n        },\n        \"ansible_architecture\": \"x86_64\",\n        \"ansible_bios_date\": \"10/16/2017\",\n        \"ansible_bios_vendor\": \"Amazon EC2\",\n        \"ansible_bios_version\": \"1.0\",\n...\n</code></pre> <p>You will get loads of useful information and you can use every bit as variables in your playbooks later on! We will use facts in a later exercise again.</p>"},{"location":"ansible-core/ansible-core-conditionals/","title":"5 - Work with conditionals","text":""},{"location":"ansible-core/ansible-core-conditionals/#objective","title":"Objective","text":"<p>In a playbook, you may want to execute different tasks, or have different goals, depending on the value of a fact (data about the remote system), a variable, or the result of a previous task. You may want the value of some variables to depend on the value of other variables. Or you may want to create additional groups of hosts based on whether the hosts match other criteria. You can do all of these things with conditionals.</p>"},{"location":"ansible-core/ansible-core-conditionals/#guide","title":"Guide","text":"<p>Ansible can use conditionals to execute tasks or plays when certain conditions are met.</p> <p>To implement a conditional, the <code>when</code> statement must be used, followed by the condition to test. The condition is expressed using one of the available operators like e.g. for comparison:</p> Operator Description <code>==</code> Compares two objects for equality. <code>!=</code> Compares two objects for inequality. <code>&gt;</code> True if the left hand side is greater than the right hand side. <code>&gt;=</code> True if the left hand side is greater or equal to the right hand side. <code>&lt;</code> True if the left hand side is lower than the right hand side. <code>&lt;=</code> True if the left hand side is lower or equal to the right hand side. <p>Ansible uses Jinja2 tests and filters in conditionals. Ansible supports all the standard tests and filters, and adds some unique ones as well.</p> <p>For more on this, please refer to the documentation: https://jinja.palletsprojects.com/en/latest/templates/</p>"},{"location":"ansible-core/ansible-core-conditionals/#step-1-install-service-conditionally","title":"Step 1 - Install service conditionally","text":"<p>As an example we would like to install an FTP server, but only on hosts that are in the <code>ftpserver</code> inventory group.</p> <p>To do that, first edit the inventory to add another group, and place <code>node2</code> in it. Make sure that that IP address of <code>node2</code> is always the same when <code>node2</code> is listed. Edit the inventory <code>~/lab_inventory/hosts</code> to look like the following listing:</p> <pre><code>[control]\nansible-1 ansible_connection=local\n\n[web]\nnode1 ansible_host=node1.example.com\nnode2 ansible_host=node2.example.com\nnode3 ansible_host=node3.example.com\n\n[ftpserver]\nnode2 ansible_host=node2.example.com\n</code></pre> <p>Next create the file <code>ftpserver.yml</code> on your control host in the <code>~/ansible-files/</code> directory:</p> <pre><code>---\n- name: Install vsftpd if hosts are in inventory group\n  hosts: all\n  tasks:\n    - name: Install FTP server when host in ftpserver group\n      ansible.builtin.package:\n        name: vsftpd\n        state: present\n      become: true\n      when: inventory_hostname in groups[\"ftpserver\"]\n</code></pre> <p>Tip</p> <p>By now you should know how to run Ansible Playbooks, we\u2019ll start to be less verbose in this guide. Go create and run it. :-)</p> <p>Run it and examine the output. The expected outcome: The task is skipped on node1, node3 and the ansible host (your control host) because they are not in the ftpserver group in your inventory file.</p> <pre><code>TASK [Install FTP server when host in ftpserver group] *******************************************\nskipping: [ansible-1]\nskipping: [node1]\nskipping: [node3]\nchanged: [node2]\n</code></pre> <p>In your condition the magic variable <code>inventory_hostname</code> is used, a variable set by Ansible itself. It contains the inventory name for the current host being iterated over in the play.</p>"},{"location":"ansible-core/ansible-core-conditionals/#step-2-find-out-exact-version-of-installed-service","title":"Step 2 - Find out exact version of installed service","text":"<p>We installed the vsftpd package, we would now be able to start the vsftp-Service (Very Secure FTP Daemon). But what version of the package is installed?  </p> <p>Lets add two more tasks to our playbook, one to gather information about all installed packages on the target host with the module package_facts. This module adds the gathered information to the <code>ansible_facts</code>, from there you can use the information as an Ansible variable. The last tasks outputs the exact version number to stdout, but only if the package is installed (the variable in the packages dictionary is defined).</p> <pre><code>---\n- name: Install vsftpd if hosts are in inventory group\n  hosts: all\n  tasks:\n    - name: Install FTP server when host in ftpserver group\n      ansible.builtin.package:\n        name: vsftpd\n        state: present\n      become: true\n      when: inventory_hostname in groups[\"ftpserver\"]\n\n    - name: Get information about installed packages\n      ansible.builtin.package_facts:\n        manager: auto\n\n    - name: Debug exact version of installed vsFTP package\n      ansible.builtin.debug:\n        msg: \"vsFTP is installed in Version {{ ansible_facts.packages.vsftpd.0.version }}\"\n      when: ansible_facts.packages.vsftpd is defined\n</code></pre> <p>As you can see, the simplest conditional statement applies to a single task. If you do this on your own, create the task, then add a <code>when</code> statement that applies a test. The <code>when</code> clause is a raw Jinja2 expression, you can use variables here, but you don't have to use double curly braces to enclose the variable.</p> <p>Tip</p> <p>Run the playbook and observe the output!</p> <p>Looking back at the playbook, why did we add the condition to the last task? We know that we installed the package, therefore the condition is always true (the variable is definitely defined) and we could live without the condition.</p> <p>You should always strive towards making your playbooks as robust as possible, what would happen if we would change the first task to de-install the service and not use the condition? Let's change the title and the state to <code>absent</code>, remove (or comment) the condition and run the playbook again.</p> <pre><code>---\n- name: Install vsftpd if hosts are in inventory group\n  hosts: all\n  tasks:\n    - name: De-install FTP server when host in ftpserver group\n      ansible.builtin.package:\n        name: vsftpd\n        state: absent\n      become: true\n      when: inventory_hostname in groups[\"ftpserver\"]\n\n    - name: Get information about installed packages\n      ansible.builtin.package_facts:\n        manager: auto\n\n    - name: Debug exact version of installed vsFTP package\n      ansible.builtin.debug:\n        msg: \"vsFTP is installed in Version {{ ansible_facts.packages.vsftpd.0.version }}\"\n    #  when: ansible_facts.packages.vsftpd is defined\n</code></pre> <p>The service is removed by the playbook, therefore the result of the package_facts module does not include the vsftpd package anymore (!) and your playbooks ends with an error message!</p>"},{"location":"ansible-core/ansible-core-conditionals/#step-3-challenge-lab","title":"Step 3 - Challenge lab","text":"<p>Add a task to the playbook which outputs a message if important security patches are included in the installed vsftpd package.</p> <ul> <li>Make sure that the vsftpd package is installed (again).</li> <li>Output the message \"The version of vsftpd includes important security patches!\" if the version of vsftpd is greater than 3.0</li> </ul> <p>Tip</p> <p>The Ansible documentation is helpful, a test to compare versions is available.</p> <p>Tip</p> <p>You need to check multiple conditions this time (if the package is installed at all and if the version is greater than 3.0)! You can use logical operators (like <code>and</code>, <code>or</code>, <code>not</code>) to combine conditions. When you have multiple conditions that all need to be true (that is, a logical <code>and</code>), you can specify them as a list. Take a look at the documentation for additional information.</p> <p>Run the extended playbook.</p> Solution <p>The updated playbook:</p> <pre><code>---\n- name: Install vsftpd if hosts are in inventory group\n  hosts: all\n  tasks:\n    - name: Install FTP server when host in ftpserver group\n      ansible.builtin.package:\n        name: vsftpd\n        state: present\n      become: true\n      when: inventory_hostname in groups[\"ftpserver\"]\n\n    - name: Get information about installed packages\n      ansible.builtin.package_facts:\n        manager: auto\n\n    - name: Debug exact version of installed vsFTP package\n      ansible.builtin.debug:\n        msg: \"{{ ansible_facts.packages.vsftpd.0.version }}\"\n      when: ansible_facts.packages.vsftpd is defined\n\n    - name: Output message when vsftpd version is greater than 3.0\n      ansible.builtin.debug:\n        msg: \"The version of vsftp includes important security patches!\"\n      when:\n        - ansible_facts.packages.vsftpd is defined\n        - ansible_facts.packages.vsftpd.0.version is version('3.0', '&gt;')\n</code></pre> <p>Running the playbook outputs the following:</p> <pre><code>...\nTASK [Output message when vsftp version is greater than 3.0] *******************************************************************\nskipping: [node1]\nskipping: [node3]\nok: [node2] =&gt; {\n    \"msg\": \"The version of vsftpd includes important security patches!\"\n}\n...\n</code></pre> <p>The message is shown? Awesome! To see if the conditions works, change the version to compare to <code>4.0</code> and run the playbook again. You should now see the last task as skipped.</p>"},{"location":"ansible-core/ansible-core-handlers/","title":"7 - Trigger changes with Handlers","text":""},{"location":"ansible-core/ansible-core-handlers/#objective","title":"Objective","text":"<p>Get to know Handler, a special task which is defined in its own play parameter. A handler is often used to restart services, but it can be used with every module Ansible offers.  </p>"},{"location":"ansible-core/ansible-core-handlers/#guide","title":"Guide","text":"<p>Sometimes when a task does make a change to the system, an additional task or tasks may need to be run. For example, a change to a service\u2019s configuration file may then require that the service be restarted so that the changed configuration takes effect.</p> <p>Here Ansible\u2019s handlers come into play. Handlers can be seen as inactive tasks that only get triggered when explicitly invoked using the \"notify\" statement. Read more about them in the Ansible Handlers documentation.</p>"},{"location":"ansible-core/ansible-core-handlers/#step-1-handlers","title":"Step 1 - Handlers","text":"<p>As a an example, let\u2019s write a playbook that:</p> <ul> <li>manages Apache\u2019s configuration file <code>/etc/httpd/conf/httpd.conf</code> on all hosts in the <code>web</code> group</li> <li>restarts Apache when the file has changed</li> </ul> <p>First we need the file Ansible will deploy, let\u2019s just take the one from node1.</p> <pre><code>scp node1:/etc/httpd/conf/httpd.conf ~/ansible-files/files/.\n</code></pre> <p>We now have the configuration file for our webserver, we will adjust the file later and copy it back to all webserver hosts later. Next, create the Playbook <code>httpd_conf.yml</code>. Make sure that you are in the directory <code>~/ansible-files</code>.</p> <pre><code>---\n- name: Manage httpd.conf\n  hosts: web\n  become: true\n  handlers:\n    - name: Restart_apache\n      ansible.builtin.service:\n        name: httpd\n        state: restarted\n  tasks:\n    - name: Copy Apache configuration file\n      ansible.builtin.copy:\n        src: httpd.conf\n        dest: /etc/httpd/conf/httpd.conf\n        mode: \"0644\"\n        owner: apache\n        group: apache\n      notify:\n        - Restart_apache\n</code></pre> <p>So what\u2019s new here?</p> <ul> <li>The \"notify\" parameter calls the handler only when the copy task actually changes the file. That way the service is only restarted if needed - and not each time the playbook is run.</li> <li>The \"handlers\" section defines a task that is only run on notification.</li> </ul> <p>Run the playbook. We didn\u2019t change anything in the file yet so there should not be any <code>changed</code> lines in the output and of course the handler shouldn\u2019t have fired.</p> <ul> <li>Now change the <code>Listen 80</code> line in <code>~/ansible-files/files/httpd.conf</code> to:</li> </ul> <pre><code>Listen 8080\n</code></pre> <ul> <li> <p>Run the playbook again. Now the Ansible\u2019s output should be a lot more interesting:</p> <ul> <li>httpd.conf should have been copied over</li> <li>The handler should have restarted Apache</li> </ul> </li> </ul> <p>Note</p> <p>By default, handlers run after all the tasks in a particular play have been completed.</p> <p>Apache should now listen on port 8080. Easy enough to verify:</p> <pre><code>[student@ansible-1 ansible-files]$ curl http://node1\ncurl: (7) Failed to connect to node1 port 80: Connection refused\n[student@ansible-1 ansible-files]$ curl http://node1:8080\n&lt;body&gt;\n&lt;h1&gt;This is a development webserver, have fun!&lt;/h1&gt;\n&lt;/body&gt;\n</code></pre> <p>Warning</p> <p>If you are using the local development environment, remember, you are using containers instead of actual VMs! You need to append the correct port (e.g. <code>curl http://node1:8002\"</code> for Port 80, <code>curl http://node1:8003\"</code> for Port 8080). Take a look at the table with the ports overview or execute <code>podman ps</code> and check the output.</p> <p>Run the playbook one last time. As the configuration file is already copied over with the desired configuration state, the handler is not triggered, Apache will keep running.</p>"},{"location":"ansible-core/ansible-core-intro/","title":"1 - Check the Prerequisites","text":""},{"location":"ansible-core/ansible-core-intro/#objective","title":"Objective","text":"<ul> <li>Understand the lab topology and how to access the environment.</li> <li>Understand how to work the workshop exercises</li> <li>Understand challenge labs</li> </ul> <p>These first few lab exercises will be exploring the command-line utilities of the Ansible Automation Platform.  This includes</p> <ul> <li>ansible-core - the base executable that provides the framework, language and functions that underpin the Ansible Automation Platform.  It also includes various cli tools like <code>ansible</code>, <code>ansible-playbook</code> and <code>ansible-doc</code>.  Ansible Core acts as the bridge between the upstream community with the free and open source Ansible and connects it to the downstream enterprise automation offering from Red Hat, the Ansible Automation Platform.</li> <li>ansible-navigator - a command line utility and text-based user interface (TUI) for running and developing Ansible automation content.</li> <li>Execution Environments - not specifically covered in this workshop (day 1) because the built-in Ansible Execution Environments already included all the Red Hat supported collections which includes all the collections we use for this workshop.  Execution Environments are container images that can be utilized as Ansible execution.</li> <li>ansible-builder - not specifically covered in this workshop, <code>ansible-builder</code> is a command line utility to automate the process of building Execution Environments.</li> </ul> <p>If you need more information on new Ansible Automation Platform components bookmark this landing page https://docs.redhat.com/en/documentation/red_hat_ansible_automation_platform/2.4</p> <p>We will be using especially the ansible-core executable and the CLI tools it provides, as currently (Q1/2023) it is still the main interface to interact with Ansible.</p> <p>In the (near) future this will be replaced/supplemented by the Ansible Navigator, which on the one hand brings more useful additional features and in the end serves a much greater purpose than just be a drop in replacement or alias to the currently used Ansible utilities. It requires a broader introduction and explanation regarding the use of containers and collections, which we will discuss on workshop day 3. Still, although we will be using the ansible-core executable in all exercises, it is shown how to also achieve everything using the <code>ansible-navigator</code> utility in a separate tab.</p> AnsibleNavigator <pre><code>[student@ansible-1 ~]$ ansible-playbook --help\nusage: ansible-playbook [-h] [--version] [-v] [--private-key PRIVATE_KEY_FILE] [-u REMOTE_USER] [-c CONNECTION] [-T TIMEOUT] [--ssh-common-args SSH_COMMON_ARGS]\n                        [--sftp-extra-args SFTP_EXTRA_ARGS] [--scp-extra-args SCP_EXTRA_ARGS] [--ssh-extra-args SSH_EXTRA_ARGS]\n                        [-k | --connection-password-file CONNECTION_PASSWORD_FILE] [--force-handlers] [--flush-cache] [-b] [--become-method BECOME_METHOD] [--become-user BECOME_USER]\n                        [-K | --become-password-file BECOME_PASSWORD_FILE] [-t TAGS] [--skip-tags SKIP_TAGS] [-C] [--syntax-check] [-D] [-i INVENTORY] [--list-hosts] [-l SUBSET]\n                        [-e EXTRA_VARS] [--vault-id VAULT_IDS] [--ask-vault-password | --vault-password-file VAULT_PASSWORD_FILES] [-f FORKS] [-M MODULE_PATH] [--list-tasks]\n                        [--list-tags] [--step] [--start-at-task START_AT_TASK]\n                        playbook [playbook ...]\n\nRuns Ansible playbooks, executing the defined tasks on the targeted hosts.\n\npositional arguments:\n  playbook              Playbook(s)\n\noptional arguments:\n\n[...]\n</code></pre> <p>Note</p> <p>By default, the ansible-navigator will start in the interactive mode. This will launch the navigator in the Text-based User Interface (TUI) mode. If you want to use the tool the same way as with the normal ansible-playbook command, provide the parameter <code>-m stdout</code> which forces the output to the command-line (though, this prevents you from experiencing the cool features of the navigator).</p> <pre><code>[student@ansible-1 ~]$ ansible-navigator --help\nusage: ansible-navigator [-h] [--version] [--rad ANSIBLE_RUNNER_ARTIFACT_DIR] [--rac ANSIBLE_RUNNER_ROTATE_ARTIFACTS_COUNT] [--rt ANSIBLE_RUNNER_TIMEOUT]\n                        [--cdcp COLLECTION_DOC_CACHE_PATH] [--ce CONTAINER_ENGINE] [--co CONTAINER_OPTIONS [CONTAINER_OPTIONS ...]] [--dc DISPLAY_COLOR] [--ecmd EDITOR_COMMAND]\n                        [--econ EDITOR_CONSOLE] [--ee EXECUTION_ENVIRONMENT] [--eei EXECUTION_ENVIRONMENT_IMAGE]\n                        [--eev EXECUTION_ENVIRONMENT_VOLUME_MOUNTS [EXECUTION_ENVIRONMENT_VOLUME_MOUNTS ...]] [--la LOG_APPEND] [--lf LOG_FILE] [--ll LOG_LEVEL] [-m MODE] [--osc4 OSC4]\n                        [--penv PASS_ENVIRONMENT_VARIABLE [PASS_ENVIRONMENT_VARIABLE ...]] [--pp PULL_POLICY] [--senv SET_ENVIRONMENT_VARIABLE [SET_ENVIRONMENT_VARIABLE ...]]\n                        {subcommand} --help ...\n\noptional arguments:\n\n[...]\n</code></pre> <p>Info</p> <p>Although the tab is titled Ansible, this can be any of the classic utilities provided by the ansible-core executable. The Navigator tab uses the same utils but acts as an abstraction layer.</p>"},{"location":"ansible-core/ansible-core-intro/#guide","title":"Guide","text":""},{"location":"ansible-core/ansible-core-intro/#your-lab-environment","title":"Your Lab Environment","text":"<p>In this lab you work in a pre-configured lab environment. You will have access to the following hosts:</p> Role Inventory name Ansible Control Host ansible-1 Managed Host 1 node1 Managed Host 2 node2 Managed Host 3 node3 <p>Every host is reachable via SSH.</p>"},{"location":"ansible-core/ansible-core-intro/#step-1-access-the-environment","title":"Step 1 - Access the Environment","text":"<p>Connect to Visual Studio Code from the Workshop launch page (provided by your instructor).  The password is provided below the WebUI link.</p> <p></p> <p>Type in the provided password to connect.</p> <p></p> <p>Clicking on <code>File</code> \u2192 <code>Open Folder...</code> in the menu bar and open your home directory in Visual Studio Code (this folder should already be shown in the Open Folder pop-up and called <code>/home/student</code>. This will reload your browser window.</p>"},{"location":"ansible-core/ansible-core-intro/#step-2-using-the-terminal","title":"Step 2 - Using the Terminal","text":"<p>Open a terminal in Visual Studio Code:</p> <p></p> <p>Navigate to the <code>lab_inventory</code> directory on the Ansible control node terminal.</p> <pre><code>[student@ansible-1 ~]$ cd lab_inventory\n[student@ansible-1 lab_inventory]$ pwd\n/home/student/lab_inventory\n[student@ansible-1 lab_inventory]$ ls\n[student@ansible-1 lab_inventory]$\nhosts\n[student@ansible-1 lab_inventory]$ cd ..\n[student@ansible-1 ~]$\n</code></pre> <ul> <li><code>~</code> - the tilde in this context is a shortcut for the home directory, i.e. <code>/home/student</code></li> <li><code>cd</code> - Linux command to change directory</li> <li><code>pwd</code> - Linux command for print working directory.  This will show the full path to the current working directory.</li> </ul>"},{"location":"ansible-core/ansible-core-intro/#step-3-challenge-labs","title":"Step 3 - Challenge Labs","text":"<p>You will soon discover that many chapters in this lab guide come with a \"Challenge Lab\" section. These labs are meant to give you a small task to solve using what you have learned so far. The solution of the task is shown underneath a warning sign.</p>"},{"location":"ansible-core/ansible-core-loops/","title":"6 - Run tasks multiple times","text":""},{"location":"ansible-core/ansible-core-loops/#objective","title":"Objective","text":"<p>Get to know the <code>loop</code>, <code>with_&lt;lookup&gt;</code>, and <code>until</code> keywords to execute a task multiple times.  </p> <p>The <code>loop</code> keyword is not yet a full replacement for <code>with_&lt;lookup&gt;</code>, but we recommend it for most use cases. Both keywords achieve the same thing (although a bit differently under the hood). You may find e.g. <code>with_items</code> in examples and the use is not (yet) deprecated - that syntax will still be valid for the foreseeable future - but try to use the <code>loop</code> keyword whenever possible. The <code>until</code> keyword is used to retry a task until a certain condition is met. For example, you could run a task up to <code>X</code> times (defined by a retries parameter) with a delay of <code>X</code> seconds between each attempt. This may be useful if your playbook has to wait for the startup of a process before continuing.</p>"},{"location":"ansible-core/ansible-core-loops/#guide","title":"Guide","text":"<p>Loops enable us to repeat the same task over and over again. For example, lets say you want to create multiple users. By using an Ansible loop, you can do that in a single task. Loops can also iterate over more than just basic lists. For example, if you have a list of users with their corresponding group, loop can iterate over them as well.  </p> <p>Find out more about loops in the Ansible Loops documentation.</p>"},{"location":"ansible-core/ansible-core-loops/#step-1-simple-loops","title":"Step 1 - Simple Loops","text":"<p>To show the loops feature we will generate three new users on <code>node1</code>. For that, create the file <code>loop_users.yml</code> in <code>~/ansible-files</code> on your control node as your student user. We will use the <code>user</code> module to generate the user accounts.</p> <pre><code>---\n- name: Demo playbook for loops\n  hosts: node1\n  become: true\n  tasks:\n    - name: Ensure multiple users are present\n      ansible.builtin.user:\n        name: \"{{ item }}\"\n        state: present\n      loop:\n        - dev_user\n        - qa_user\n        - prod_user\n</code></pre> <p>Understand the playbook and the output:</p> <ul> <li>The names are not provided to the user module directly. Instead, there is only a variable called <code>{{ item }}</code> for the parameter <code>name</code>.</li> <li>The <code>loop</code> keyword lists the actual user names. Those replace the <code>{{ item }}</code> during the actual execution of the playbook.</li> <li>During execution the task is only listed once, but there are three changes listed underneath it.</li> </ul>"},{"location":"ansible-core/ansible-core-loops/#step-2-loops-over-hashes","title":"Step 2 - Loops over hashes","text":"<p>As mentioned loops can also be over lists of hashes (multiple key-value-pairs in every list item). Imagine that the users should be assigned to different additional groups:</p> <pre><code>- username: dev_user\n  group: ftp\n- username: qa_user\n  group: apache\n- username: prod_user\n  group: admin\n</code></pre> <p>The <code>user</code> module has the optional parameter <code>groups</code> which defines the group (or list of groups) the user should be added to. To reference items in a hash, the <code>{{ item }}</code> keyword needs to reference the sub-key: <code>{{ item.group }}</code> for example.</p> Hint <p>By default, the user is removed from all other groups. Use the module parameter <code>append: true</code> to modify this.</p> <p>Let's rewrite the playbook to create the users with additional user rights:</p> <pre><code>---\n- name: Demo playbook for loops\n  hosts: node1\n  become: true\n  tasks:\n    - name: Ensure multiple users are present\n      ansible.builtin.user:\n        name: \"{{ item.username }}\"\n        state: present\n        groups: \"{{ item.group }}\"\n      loop:\n        - username: dev_user\n          group: ftp\n        - username: qa_user\n          group: apache\n        - username: prod_user\n          group: admin\n</code></pre> <p>Check the output:</p> <ul> <li>Again the task is listed once, but three changes are listed. Each loop item with its content is shown.</li> </ul> <p>Failure</p> <p>At least one user was not created because of a missing group, the playbook failed? Well, we did not create all groups, the user-module does not do this! Some groups are already present, either they were present by default or were created when we installed packages, other groups must be created before we can use them.  </p> <p>Success</p> <p>To ensure all groups are created, before you reference them, add one more task which creates the groups for you! Use the <code>ansible.builtin.group</code> module and loop over the same list as the task which creates the users, this list contains all groups which need to be created.</p> Need help? <pre><code>---\n- name: Demo playbook for loops\n  hosts: node1\n  become: true\n  tasks:\n    # Looping over same list as the next task, but only using/referencing the groups key\n    - name: Ensure groups are present\n      ansible.builtin.group:\n        name: \"{{ item.group }}\"\n        state: present\n      loop:\n        - username: dev_user\n          group: ftp\n        - username: qa_user\n          group: apache\n        - username: prod_user\n          group: admin\n\n    - name: Ensure multiple users are present\n      ansible.builtin.user:\n        name: \"{{ item.username }}\"\n        state: present\n        groups: \"{{ item.group }}\"\n      loop:\n        - username: dev_user\n          group: ftp\n        - username: qa_user\n          group: apache\n        - username: prod_user\n          group: admin\n</code></pre> <p>Instead of repeating the list in the loop, you can (and should!) relocate the loop content to a variable and reference this one. Take a look at the following playbook:</p> <pre><code>---\n- name: Demo playbook for loops\n  hosts: node1\n  become: true\n  vars:\n    user_and_group_list:\n      - username: dev_user\n        group: ftp\n      - username: qa_user\n        group: apache\n      - username: prod_user\n        group: admin\n  tasks:\n    - name: Ensure groups are present\n      ansible.builtin.group:\n        name: \"{{ item.group }}\"\n        state: present\n      loop: \"{{ user_and_group_list }}\"\n\n    - name: Ensure multiple users are present\n      ansible.builtin.user:\n        name: \"{{ item.username }}\"\n        state: present\n        groups: \"{{ item.group }}\"\n      loop: \"{{ user_and_group_list }}\"\n</code></pre> <p>Run the playbook again to ensure all users (and groups) are created!</p> <p>Afterwards, verify that the user <code>prod_user</code> was indeed created on <code>node1</code> using the following playbook, name it <code>user_id.yml</code>:</p> <pre><code>---\n- name: Get user ID play\n  hosts: node1\n  vars:\n    myuser: \"prod_user\"\n  tasks:\n    - name: Get info for {{ myuser }}\n      ansible.builtin.getent:\n        database: passwd\n        key: \"{{ myuser }}\"\n\n    - name: Output info for {{ myuser }}\n      ansible.builtin.debug:\n        msg: \"{{ myuser }} uid: {{ getent_passwd[myuser][1] }}\"\n</code></pre> AnsibleNavigator <pre><code>$ ansible-playbook user_id.yml\n\nPLAY [Get user ID play] ******************************************************************************************\n\nTASK [Gathering Facts] *******************************************************************************************\nok: [node1]\n\nTASK [Get info for prod_user] *****************************************************************************************\nok: [node1]\n\nTASK [Output info for prod_user] **************************************************************************************\nok: [node1] =&gt; {\n    \"msg\": [\n        \"prod_user uid: 1002\"\n    ]\n}\n\nPLAY RECAP *******************************************************************************************************\nnode1                      : ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0  \n</code></pre> <pre><code>$ ansible-navigator run user_id.yml -m stdout\n\nPLAY [Get user ID play] ******************************************************************************************\n\nTASK [Gathering Facts] *******************************************************************************************\nok: [node1]\n\nTASK [Get info for prod_user] *****************************************************************************************\nok: [node1]\n\nTASK [Output info for prod_user] **************************************************************************************\nok: [node1] =&gt; {\n    \"msg\": [\n        \"prod_user uid: 1002\"\n    ]\n}\n\nPLAY RECAP *******************************************************************************************************\nnode1                      : ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0  \n</code></pre> <p>Hint</p> <p>It is possible to insert a string directly into the dictionary structure like this (although it makes the task less flexible): <pre><code>- name: Output info for user\n  ansible.builtin.debug:\n    msg: \"{{ myuser }} uid: {{ getent_passwd[myuser]['prod_user'][1] }}\"\n</code></pre> As you can see the value (<code>prod_user</code>) of the variable <code>myuser</code> is used directly. It must be enclosed in single quotes. You can't use normal quotation marks, as these are used outside of the whole variable.</p>"},{"location":"ansible-core/ansible-core-loops/#step-3-loops-with-list-variable","title":"Step 3 - Loops with list-variable","text":"<p>Up to now, we always provided the list to loop in the loop keyword directly, most of the times you will provide the list with a variable.</p> <pre><code>---\n- name: Use Ansible magic variables\n  hosts: control\n  tasks:\n    - name: Show all the hosts in the inventory\n      ansible.builtin.debug:\n        msg: \"{{ item }}\"\n      loop: \"{{ groups['all'] }}\"\n\n    - name: Show all the hosts in the current play\n      ansible.builtin.debug:\n        msg: \"{{ item }}\"\n      loop: \"{{ ansible_play_hosts }}\"\n</code></pre> <p>This playbook uses two magic variables, these variables cannot be set directly by the user and are always defined. The second task for example, uses the special variable <code>ansible_play_hosts</code>, which contains a list of hosts in the current play run, failed or unreachable hosts are excluded from this list. The first task uses the special variable <code>groups</code>, this contains a dictionary with all the groups in the inventory and each group has the list of hosts that belong to it. Copy the contents to a file <code>special-variables.yml</code> and run the playbook. We can use the playbook to display that the loop keyword needs list-input, if you provide otherwise, Ansible will display an error message.</p> <pre><code>fatal: [node1]: FAILED! =&gt; {\"msg\": \"Invalid data passed to 'loop', it requires a list, got this instead: {'all': ['node1', 'node2', 'node3'], 'ungrouped': [], 'web': ['node1', 'node2', 'node3']}. Hint: If you passed a list/dict of just one element, try adding wantlist=True to your lookup invocation or use q/query instead of lookup.\"}\n</code></pre> <p>You can provoke this, if you change line 8 to <code>loop: \"{{ groups }}\"</code>. With that change you would try to loop a dictionary, this obviously fails.</p>"},{"location":"ansible-core/ansible-core-playbook/","title":"3 - Writing your first Playbook","text":""},{"location":"ansible-core/ansible-core-playbook/#objective","title":"Objective","text":"<p>This exercise covers using Ansible to build two Apache web servers on Red Hat Enterprise Linux. This exercise covers the following Ansible fundamentals:</p> <ul> <li>Understanding Ansible module parameters</li> <li>Understanding and using the following modules<ul> <li>package module</li> <li>service module</li> <li>copy module</li> </ul> </li> <li>Understanding Idempotence and how Ansible modules can be idempotent</li> </ul>"},{"location":"ansible-core/ansible-core-playbook/#guide","title":"Guide","text":"<p>Playbooks are files which describe the desired configurations or steps to implement on managed hosts. Playbooks can change lengthy, complex administrative tasks into easily repeatable routines with predictable and successful outcomes.</p> <p>A playbook can have multiple plays and a play can have one or multiple tasks. In a task a module is called, like the modules in the previous chapter. The goal of a play is to map a group of hosts.  The goal of a task is to implement modules against those hosts.</p> <p>Tip</p> <p>Here is a nice analogy: When Ansible modules are the tools in your workshop, the inventory is the materials and the Playbooks are the instructions.</p>"},{"location":"ansible-core/ansible-core-playbook/#step-1-playbook-basics","title":"Step 1 - Playbook Basics","text":"<p>Playbooks are text files written in YAML format and therefore need:</p> <ul> <li> <p>to start with three dashes (<code>---</code>)</p> </li> <li> <p>proper indentation using spaces and not tabs!</p> </li> </ul> <p>There are some important concepts:</p> <ul> <li> <p>hosts: the managed hosts to perform the tasks on</p> </li> <li> <p>tasks: the operations to be performed by invoking Ansible modules and passing them the necessary options</p> </li> <li> <p>become: privilege escalation in playbooks</p> </li> </ul> <p>Warning</p> <p>The ordering of the contents within a Playbook is important, because Ansible executes plays and tasks in the order they are presented.</p> <p>A Playbook should be idempotent, so if a Playbook is run once to put the hosts in the correct state, it should be safe to run it a second time and it should make no further changes to the hosts.</p> <p>Tip</p> <p>Most Ansible modules are idempotent, so it is relatively easy to ensure this is true.</p>"},{"location":"ansible-core/ansible-core-playbook/#step-2-directory-structure-and-files-for-your-playbook","title":"Step 2 - Directory Structure and files for your Playbook","text":"<p>Enough theory, it\u2019s time to create your first Ansible playbook. In this lab you create a playbook to set up an Apache web server in three steps:</p> <ol> <li>Install httpd package</li> <li>Enable/start httpd service</li> <li>Copy over an web.html file to each web host</li> </ol> <p>This Playbook makes sure the package containing the Apache web server is installed on <code>node1</code>.</p> <p>There is a best practice Guide on the preferred directory structures for playbooks.  We strongly encourage you to read and understand these practices as you develop your Ansible skills. That said, our playbook today is very basic and creating a complex structure will just confuse things.</p> <p>Instead, we are going to create a very simple directory structure for our playbook, and add just a couple of files to it.</p> <p>On your control host ansible-1, create a directory called <code>ansible-files</code> in your home directory and change directories into it:</p> <pre><code>[student@ansible-1 ~]$ mkdir ansible-files\n[student@ansible-1 ~]$ cd ansible-files/\n</code></pre> <p>Add a file called <code>apache.yml</code> with the following content. As discussed in the previous exercises, use <code>vi</code>/<code>vim</code> or, if you are new to editors on the command line, check out the editor alternatives again.</p> <pre><code>---\n- name: Apache server installed\n  hosts: node1\n  become: true\n</code></pre> <p>This shows one of Ansible\u2019s strengths: The Playbook syntax is easy to read and understand. In this Playbook:</p> <ul> <li>A name is given for the play via <code>name:</code>.</li> <li>The host to run the playbook against is defined via <code>hosts:</code>.</li> <li>We enable user privilege escalation with <code>become:</code>.</li> </ul> <p>Tip</p> <p>You obviously need to use privilege escalation to install a package or run any other task that requires root permissions. This is done in the Playbook by <code>become: true</code>.</p> <p>Now that we've defined the play, let's add a task to get something done. We will add a task in which the RHEL package manager will ensure that the Apache package is installed in the latest version. Modify the file so that it looks like the following listing:</p> <pre><code>---\n- name: Apache server installed\n  hosts: node1\n  become: true\n  tasks:\n    - name: Install Apache package\n      ansible.builtin.package:\n        name: httpd\n        state: present\n</code></pre> <p>Tip</p> <p>Since playbooks are written in YAML, alignment of the lines and keywords is crucial. Make sure to vertically align the t in <code>task</code> with the b in <code>become</code>. Once you are more familiar with Ansible, make sure to take some time and study a bit the YAML Syntax.</p> <p>In the added lines:</p> <ul> <li>We started the tasks part with the keyword <code>tasks:</code>.</li> <li>A task is named and the module for the task is referenced. Here it uses the <code>package</code> module.</li> <li>Parameters for the module are added:<ul> <li><code>name:</code> to identify the package name</li> <li><code>state:</code> to define the wanted state of the package</li> </ul> </li> </ul> <p>Tip</p> <p>The module parameters are individual to each module. If in doubt, look them up again with <code>ansible-doc</code>.</p> <p>Save your playbook and exit your editor.</p>"},{"location":"ansible-core/ansible-core-playbook/#step-3-running-the-playbook","title":"Step 3 - Running the Playbook","text":"<p>To run your playbook, use the <code>ansible-playbook &lt;playbook&gt;</code> command as follows:</p> AnsibleNavigator <pre><code>[student@ansible-1 ansible-files]$ ansible-playbook apache.yml\n</code></pre> What does <code>Invalid callback for stdout specified</code> mean? <p>If you see this error, this is not your fault, but a missing plugin. In the demo environment, only the <code>ansible-core</code> package is installed. The missing plugin (a callback plugin formats the output Ansible is producing) is not part of the <code>ansible.builtin</code> collection, you need to install it.</p> <pre><code>ansible-galaxy collection install community.general\n</code></pre> <p>If you want to know where this configuration is stored, take a look at the following tip.</p> <pre><code>[student@ansible-1 ansible-files]$ ansible-navigator run apache.yml -m stdout\n</code></pre> <p>Tip</p> <p>The existing <code>/etc/ansible/ansible.cfg</code> file provides the location of your inventory file. If this was not set within your <code>ansible.cfg</code> file, the command to run the playbook would be:</p> <pre><code>ansible-playbook -i /home/student/lab_inventory/hosts apache.yml\n</code></pre> <p>The configuration file does set some more parameters, take a look. If you want to know which config file is used and where it is stored, run <code>ansible --version</code>. The output shows the currently used config file.</p> <p>Once the playbook has completed, connect to <code>node1</code> via SSH to make sure Apache has been installed:</p> <pre><code>[student@ansible-1 ansible-files]$ ssh node1\nLast login: Wed May 15 14:03:45 2019 from 44.55.66.77\nManaged by Ansible\n</code></pre> <p>Use the command <code>rpm -qi httpd</code> to verify httpd is installed:</p> <pre><code>[ec2-user@node1 ~]$ rpm -qi httpd\nName        : httpd\nVersion     : 2.4.37\n[...]\n</code></pre> <p>Log out of <code>node1</code> with the command <code>exit</code> so that you are back on the control host and verify the installed package with an Ansible playbook named <code>package.yml</code>. Create the file and paste in the following content:</p> <pre><code>---\n- name: Check packages\n  hosts: node1\n  become: true\n  vars:\n    package: \"httpd\"\n  tasks:\n    - name: Gather the package facts\n      ansible.builtin.package_facts:\n        manager: auto\n\n    - name: Output message if package is installed\n      ansible.builtin.debug:\n        msg: \"{{ package }} in Version {{ ansible_facts.packages[package][0].version }} is installed!\"\n</code></pre> <p>Note</p> <p>The playbook (and some of the following playbooks) make use of variables, you will learn about them in the next chapter.</p> <p>The playbook has two tasks, the first one uses the <code>package_facts</code> module, it does what it says, it gathers information about packages. These facts are not gathered by default with the \"Gather facts\" tasks (which uses the <code>setup</code> module) and must be collected separately. The second task uses the <code>debug</code> module. The variable ansible_facts is extended with the packages key, which contains a dictionary with all packages installed on the managed node. The httpd package could be installed in multiple versions, therefore every package key, in our case httpd, is a list. We have installed only one version of httpd (thus, we have a list with only one element), we get the version of httpd with <code>[0].version</code>.  </p> AnsibleNavigator <pre><code>[student@ansible-1 ~]$ ansible-playbook package.yml\n</code></pre> <pre><code>[student@ansible-1 ~]$ ansible-navigator run package.yml -m stdout\n</code></pre> <p>The output should look like this:</p> <pre><code>PLAY [Check packages] **********************************************************\n\nTASK [Gathering Facts] *********************************************************\nok: [ansible]\n\nTASK [Gather the package facts] ************************************************\nok: [ansible]\n\nTASK [Check whether a httpd  is installed] *************************************\nok: [ansible] =&gt; {\n    \"msg\": \"httpd 2.4.37 is installed!\"\n}\n\nPLAY RECAP *********************************************************************\nansible                    : ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0  \n</code></pre> <p>Execute the command <code>ansible-playbook apache.yml</code> for a second time, and compare the output.</p>"},{"location":"ansible-core/ansible-core-playbook/#step-4-add-one-more-task","title":"Step 4 - Add one more task","text":"<p>The next part of the Ansible playbook makes sure the Apache application is enabled and started on <code>node1</code>.</p> <p>On the control host, as your student user, edit the file <code>~/ansible-files/apache.yml</code> to add a second task using the <code>service</code> module. The Playbook should now look like this:</p> <pre><code>---\n- name: Apache server installation\n  hosts: node1\n  become: true\n  tasks:\n    - name: Install Apache package\n      ansible.builtin.package:\n        name: httpd\n        state: present\n\n    - name: Ensure Apache is enabled and running\n      ansible.builtin.service:\n        name: httpd.service\n        enabled: true\n        state: started\n</code></pre> <p>What exactly did we do?</p> <ul> <li>a second task named \"Apache enabled and running\" is created</li> <li>a module is specified (<code>service</code>)</li> <li>The module <code>service</code> takes the name of the service (<code>httpd</code>), if it should be permanently set (<code>enabled</code>), and its current state (<code>started</code>)</li> </ul> <p>Thus with the second task we make sure the Apache server is indeed running on the target machine. Run your extended Playbook:</p> AnsibleNavigator <pre><code>[student@ansible-1 ~]$ ansible-playbook apache.yml\n</code></pre> <pre><code>[student@ansible-1 ~]$ ansible-navigator run apache.yml -m stdout\n</code></pre> <p>You may also run the playbook in interactive mode:</p> <pre><code>[student@ansible-1 ~]$ ansible-navigator run apache.yml -m interactive\n</code></pre> <p>Notice in the output, we see the play had <code>1</code> \"CHANGED\" shown in yellow. Press <code>0</code> to enter the play output, you can see that task 2, \"Ensure Apache is enabled and running\", was the task that incorporated the latest change by the \"CHANGED\" value being set to True and highlighted in yellow.</p> <ul> <li> <p>Run the playbook a second time  to get used to the change in the output.</p> </li> <li> <p>Use an Ansible playbook labeled <code>service_state.yml</code> to make sure the Apache (httpd) service is running on <code>node1</code>.</p> </li> </ul> <pre><code>---\n- name: Check Service status\n  hosts: node1\n  become: true\n  vars:\n    service: \"httpd.service\"\n  tasks:\n    - name: Get state of all service\n      ansible.builtin.service_facts:\n\n    - name: Output service state of {{ service }}\n      ansible.builtin.debug:\n        msg: \"{{ ansible_facts['services'][service]['state'] }}\"\n</code></pre> AnsibleNavigator <pre><code>[student@ansible-1 ~]$ ansible-playbook service_state.yml\n</code></pre> <pre><code>[student@ansible-1 ~]$ ansible-navigator run service_state.yml -m stdout\n</code></pre> <p>This would be the same as checking the service state manually on <code>node1</code> with: <code>systemctl status httpd</code>.</p>"},{"location":"ansible-core/ansible-core-playbook/#step-5-extend-your-playbook","title":"Step 5 - Extend your Playbook","text":"<p>Check that the tasks were executed correctly and Apache is accepting connections: Make an HTTP request using Ansible\u2019s <code>uri</code> module in a playbook named <code>check_httpd.yml</code> from the control node to <code>node1</code>.</p> <pre><code>---\n- name: Check URL\n  hosts: control\n  vars:\n    node: \"node1\"\n  tasks:\n    - name: Check that you can connect (GET) to a page and it returns a status 200\n      ansible.builtin.uri:\n        url: \"http://{{ node }}\"\n</code></pre> <p>Warning</p> <p>Expect a lot of red lines and a 403 status! If you are using the local development environment, remember, you are using containers instead of actual VMs! You need to append the correct port (e.g. <code>node: \"node1:8002\"</code>). Take a look at the table with the ports overview or execute <code>podman ps</code> and check the output.</p> AnsibleNavigator <pre><code>[student@ansible-1 ~]$ ansible-playbook check_httpd.yml\n</code></pre> <pre><code>[student@ansible-1 ~]$ ansible-navigator run check_httpd.yml -m stdout\n</code></pre> <p>There are a lot of red lines and an error: As long as there is not at least an <code>index.html</code> file to be served by Apache, it will throw an ugly \"HTTP Error 403: Forbidden\" status and Ansible will report an error.</p> <p>So why not use Ansible to deploy a simple <code>index.html</code> file? On the ansible control host, as the <code>student</code> user, create the directory <code>files</code> to hold file resources in <code>~/ansible-files/</code>:</p> <pre><code>[student@ansible-1 ansible-files]$ mkdir files\n</code></pre> <p>Then create the file <code>~/ansible-files/files/web.html</code> on the control node:</p> <pre><code>&lt;body&gt;\n&lt;h1&gt;Apache is running fine&lt;/h1&gt;\n&lt;/body&gt;\n</code></pre> <p>In a previous example, you used Ansible\u2019s <code>copy</code> module to write text supplied on the command line into a file. Now you\u2019ll use the module in your playbook to copy a file.</p> <p>On the control node as your student user edit the file <code>~/ansible-files/apache.yml</code> and add a new task utilizing the <code>copy</code> module. It should now look like this:</p> <pre><code>---\n- name: Apache server installation\n  hosts: node1\n  become: true\n  tasks:\n    - name: Install Apache package\n      ansible.builtin.package:\n        name: httpd\n        state: present\n\n    - name: Ensure Apache is enabled and running\n      ansible.builtin.service:\n        name: httpd.service\n        enabled: true\n        state: started\n\n    - name: Copy file for webserver index\n      ansible.builtin.copy:\n        src: web.html\n        dest: /var/www/html/index.html\n        mode: \"0644\"\n        owner: apache\n        group: apache\n</code></pre> <p>What does this new copy task do? The new task uses the <code>copy</code> module and defines the source and destination options for the copy operation as parameters.</p> <p>Run your extended Playbook:</p> AnsibleNavigator <pre><code>[student@ansible-1 ansible-files]$ ansible-playbook apache.yml\n</code></pre> <pre><code>[student@ansible-1 ansible-files]$ ansible-navigator run apache.yml -m stdout\n</code></pre> <ul> <li> <p>Have a good look at the output, notice the changes of \"CHANGED\" and the tasks associated with that change.</p> </li> <li> <p>Run the Ansible playbook <code>check_httpd.yml</code> using the \"uri\" module from above again to test Apache. The command should now return a friendly green \"status: 200\" line, amongst other information.</p> </li> </ul>"},{"location":"ansible-core/ansible-core-playbook/#step-6-practice-apply-to-multiple-host","title":"Step 6 - Practice: Apply to Multiple Host","text":"<p>While the above, shows the simplicity of applying changes to a particular host. What about if you want to set changes to many hosts? This is where you'll notice the real power of Ansible as it applies the same set of tasks reliably to many hosts.</p> <ul> <li>So what about changing the apache.yml Playbook to run on <code>node1</code> and <code>node2</code> and <code>node3</code>?</li> </ul> <p>As you might remember, the inventory lists all nodes as members of the group <code>web</code>:</p> <pre><code>[web]\nnode1 ansible_host=node1.example.com\nnode2 ansible_host=node2.example.com\nnode3 ansible_host=node3.example.com\n</code></pre> <p>Change the playbook <code>hosts</code> parameter to point to <code>web</code> instead of <code>node1</code>:</p> <pre><code>---\n- name: Apache server installation\n  hosts: web\n  become: true\n  tasks:\n    - name: Install Apache package\n      ansible.builtin.package:\n        name: httpd\n        state: present\n\n    - name: Ensure Apache is enabled and running\n      ansible.builtin.service:\n        name: httpd.service\n        enabled: true\n        state: started\n\n    - name: Copy file for webserver index\n      ansible.builtin.copy:\n        src: web.html\n        dest: /var/www/html/index.html\n        mode: \"0644\"\n        owner: apache\n        group: apache\n</code></pre> <p>Now run the playbook:</p> AnsibleNavigator <pre><code>[student@ansible-1 ansible-files]$ ansible-playbook apache.yml\n</code></pre> <pre><code>[student@ansible-1 ansible-files]$ ansible-navigator run apache.yml -m stdout\n</code></pre> <p>Verify if Apache is now running on all web servers (node1, node2, node3). All output should be green.</p>"},{"location":"ansible-core/ansible-core-roles/","title":"9 - Reusability with Roles","text":""},{"location":"ansible-core/ansible-core-roles/#objective","title":"Objective","text":"<p>While it is possible to write a playbook in one file as we've done throughout this workshop, eventually you\u2019ll want to reuse files and start to organize things.</p> <p>Ansible Roles are the way we do this.  When you create a role, you deconstruct your playbook into parts and those parts sit in a directory structure.  This is explained in more details in Ansible documentation in Roles or in Sample Ansible setup.</p> <p>This exercise will cover:</p> <ul> <li>the folder structure of an Ansible Role</li> <li>how to build an Ansible Role</li> <li>creating an Ansible Play to use and execute a role</li> <li>using Ansible to create a Apache VirtualHost on node2</li> </ul>"},{"location":"ansible-core/ansible-core-roles/#guide","title":"Guide","text":""},{"location":"ansible-core/ansible-core-roles/#step-1-understanding-the-ansible-role-structure","title":"Step 1 - Understanding the Ansible Role Structure","text":"<p>Roles follow a defined directory structure; a role is named by the top level directory. Some of the subdirectories contain YAML files, named <code>main.yml</code>. The files and templates subdirectories can contain objects referenced by the YAML files.</p> <p>An example project structure could look like this, the name of the role would be \"apache\":</p> <pre><code>apache/\n\u251c\u2500\u2500 defaults\n\u2502   \u2514\u2500\u2500 main.yml\n\u251c\u2500\u2500 files\n\u251c\u2500\u2500 handlers\n\u2502   \u2514\u2500\u2500 main.yml\n\u251c\u2500\u2500 meta\n\u2502   \u2514\u2500\u2500 main.yml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 tasks\n\u2502   \u2514\u2500\u2500 main.yml\n\u251c\u2500\u2500 templates\n\u251c\u2500\u2500 tests\n\u2502   \u251c\u2500\u2500 inventory\n\u2502   \u2514\u2500\u2500 test.yml\n\u2514\u2500\u2500 vars\n    \u2514\u2500\u2500 main.yml\n</code></pre> <p>The various <code>main.yml</code> files contain content depending on their location in the directory structure shown above. For instance, <code>vars/main.yml</code> references variables, <code>handlers/main.yaml</code> describes handlers, and so on. Note that in contrast to playbooks, the <code>main.yml</code> files only contain the specific content and not additional playbook information like hosts, <code>become</code> or other keywords.</p> <p>Tip</p> <p>There are actually two directories for variables: <code>vars</code> and <code>default</code>. Default variables, <code>defaults/main.yml</code>, have the lowest precedence and usually contain default values set by the role authors and are often used when it is intended that their values will be overridden. Variables set in <code>vars/main.yml</code> are for variables not intended to be modified.</p> <p>Using roles in a Playbook is straight forward:</p> <pre><code>---\n- name: Launch roles\n  hosts: web\n  roles:\n    - role1\n    - role2\n</code></pre> <p>For each role, the tasks, handlers and variables of that role will be included in the Playbook, in that order. Any copy, script, template, or include tasks in the role can reference the relevant files, templates, or tasks without absolute or relative path names. Ansible will look for them in the role's files, templates, or tasks respectively, based on their use.</p>"},{"location":"ansible-core/ansible-core-roles/#step-2-create-a-basic-role-directory-structure","title":"Step 2 - Create a Basic Role Directory Structure","text":"<p>Ansible looks for roles in a subdirectory called <code>roles</code> in the project directory. This can be overridden in the Ansible configuration. Each role has its own directory. To ease creation of a new role the tool <code>ansible-galaxy</code> can be used.</p> <p>Tip</p> <p>Ansible Galaxy is your hub for finding, reusing and sharing the best Ansible content. <code>ansible-galaxy</code> helps to interact with Ansible Galaxy. For now we'll just using it as a helper to build the directory structure.</p> <p>Okay, lets start to build a role. We'll build a role that installs and configures Apache to serve a virtual host. Run these commands in your <code>~/ansible-files</code> directory:</p> <pre><code>[student@ansible-1 ansible-files]$ mkdir roles\n[student@ansible-1 ansible-files]$ ansible-galaxy init --offline roles/apache-webserver\n</code></pre> <p>Have a look at the role directories and their content:</p> <pre><code>[student@ansible-1 ansible-files]$ tree roles\n</code></pre> <pre><code>roles/\n\u2514\u2500\u2500 apache-webserver\n    \u251c\u2500\u2500 defaults\n    \u2502   \u2514\u2500\u2500 main.yml\n    \u251c\u2500\u2500 files\n    \u251c\u2500\u2500 handlers\n    \u2502   \u2514\u2500\u2500 main.yml\n    \u251c\u2500\u2500 meta\n    \u2502   \u2514\u2500\u2500 main.yml\n    \u251c\u2500\u2500 README.md\n    \u251c\u2500\u2500 tasks\n    \u2502   \u2514\u2500\u2500 main.yml\n    \u251c\u2500\u2500 templates\n    \u251c\u2500\u2500 tests\n    \u2502   \u251c\u2500\u2500 inventory\n    \u2502   \u2514\u2500\u2500 test.yml\n    \u2514\u2500\u2500 vars\n        \u2514\u2500\u2500 main.yml\n</code></pre>"},{"location":"ansible-core/ansible-core-roles/#step-3-create-the-tasks-file","title":"Step 3 - Create the Tasks File","text":"<p>The <code>main.yml</code> file in the tasks subdirectory of the role should do the following:</p> <ul> <li>Make sure httpd is installed</li> <li>Make sure httpd is started and enabled</li> <li>Put HTML content into the Apache document root</li> <li>Install the template provided to configure the vhost</li> </ul> <p>Note</p> <p>The <code>main.yml</code> (and other files possibly included by main.yml) can only contain tasks, not complete playbooks!</p> <p>Edit the <code>roles/apache-webserver/tasks/main.yml</code> file:</p> <pre><code>---\n- name: Install httpd package\n  ansible.builtin.package:\n    name: httpd\n    state: present\n\n- name: Start and enable httpd service\n  ansible.builtin.service:\n    name: httpd\n    state: started\n    enabled: true\n</code></pre> <p>Note that here just tasks were added. The details of a playbook are not present.</p> <p>The tasks added so far do:</p> <ul> <li>Install the httpd package using the package module</li> <li>Use the service module to enable and start httpd</li> </ul> <p>Next we add two more tasks to ensure a vhost directory structure on the managed nodes and copy HTML content:</p> <pre><code>- name: Ensure vhost directory is present\n  ansible.builtin.file:\n    path: \"/var/www/vhosts/{{ ansible_hostname }}\"\n    state: directory\n    mode: \"0755\"\n    owner: apache\n    group: apache\n\n- name: Deliver html content\n  ansible.builtin.copy:\n    src: web.html\n    dest: \"/var/www/vhosts/{{ ansible_hostname }}/index.html\"\n    mode: \"0644\"\n    owner: apache\n    group: apache\n</code></pre> <p>Note that the vhost directory is created/ensured using the <code>file</code> module.</p> <p>Info</p> <p>The term Virtual Host refers to the practice of running more than one web site (such as company1.example.com and company2.example.com) on a single machine. The fact that they are running on the same physical server is not apparent to the end user.</p> <p>The last task we add uses the template module to create the vhost configuration file from a j2-template:</p> <pre><code>- name: Deploy vhost template\n  ansible.builtin.template:\n    src: vhost.conf.j2\n    dest: /etc/httpd/conf.d/vhost.conf\n    owner: root\n    group: root\n    mode: \"0644\"\n  notify:\n    - Restart_httpd\n</code></pre> <p>Note it is using a handler to restart httpd after an configuration update.</p> <p>The full <code>tasks/main.yml</code> file is:</p> <pre><code>---\n- name: Install httpd package\n  ansible.builtin.package:\n    name: httpd\n    state: present\n\n- name: Start and enable httpd service\n  ansible.builtin.service:\n    name: httpd\n    state: started\n    enabled: true\n\n- name: Ensure vhost directory is present\n  ansible.builtin.file:\n    path: \"/var/www/vhosts/{{ ansible_hostname }}\"\n    state: directory\n    mode: \"0755\"\n\n- name: Deliver html content\n  ansible.builtin.copy:\n    src: web.html\n    dest: \"/var/www/vhosts/{{ ansible_hostname }}/index.html\"\n    mode: \"0644\"\n\n- name: Deploy vhost template\n  ansible.builtin.template:\n    src: vhost.conf.j2\n    dest: /etc/httpd/conf.d/vhost.conf\n    owner: root\n    group: root\n    mode: \"0644\"\n  notify:\n    - Restart_httpd\n</code></pre>"},{"location":"ansible-core/ansible-core-roles/#step-4-create-the-handler","title":"Step 4 - Create the handler","text":"<p>Create the handler in the file <code>roles/apache-webserver/handlers/main.yml</code> to restart httpd when notified by the template task:</p> <pre><code>---\n# handlers file for roles/apache-webserver\n- name: Restart_httpd\n  ansible.builtin.service:\n    name: httpd\n    state: restarted\n</code></pre>"},{"location":"ansible-core/ansible-core-roles/#step-5-create-the-webhtml-and-vhost-configuration-file-template","title":"Step 5 - Create the web.html and vhost configuration file template","text":"<p>Create the HTML content that will be served by the webserver.</p> <ul> <li>Create an <code>web.html</code> file in the \"src\" directory of the role, the <code>files</code> folder. Add a simple HTML content to the file:</li> </ul> <pre><code>&lt;body&gt;\n    &lt;h1&gt;The virtual host configuration works!&lt;/h1&gt;\n&lt;/body&gt;\n</code></pre> <ul> <li>Create the <code>vhost.conf.j2</code> template file in the role's <code>templates</code> subdirectory.</li> </ul> <p>The contents of the <code>vhost.conf.j2</code> template file are found below.</p> <pre><code># {{ ansible_managed }}\n\n&lt;VirtualHost *:8080&gt;\n    ServerAdmin webmaster@{{ ansible_fqdn }}\n    ServerName {{ ansible_fqdn }}\n    ErrorLog logs/{{ ansible_hostname }}-error.log\n    CustomLog logs/{{ ansible_hostname }}-common.log common\n    DocumentRoot /var/www/vhosts/{{ ansible_hostname }}/\n\n    &lt;Directory /var/www/vhosts/{{ ansible_hostname }}/&gt;\n  Options +Indexes +FollowSymlinks +Includes\n  Order allow,deny\n  Allow from all\n    &lt;/Directory&gt;\n&lt;/VirtualHost&gt;\n</code></pre> <p>Warning</p> <p>The vhost configuration expects that the webserver announces on Port 8080, the configuration was adjusted in a previous exercise.</p>"},{"location":"ansible-core/ansible-core-roles/#step-6-test-the-role","title":"Step 6 - Test the role","text":"<p>You are ready to test the role against <code>node2</code>. But since a role cannot be assigned to a node directly, first create a playbook which connects the role and the host. Create the file <code>test_apache_role.yml</code> in the directory <code>~/ansible-files</code>:</p> <pre><code>---\n- name: Use apache-webserver role\n  hosts: node2\n  become: true\n  pre_tasks:\n    - name: Output info before any role execution\n      ansible.builtin.debug:\n        msg: \"Beginning web server configuration.\"\n  post_tasks:\n    - name: Output info before all roles are executed\n      ansible.builtin.debug:\n        msg: \"Web server has been configured.\"\n  roles:\n    - apache-webserver\n</code></pre> <p>Note the <code>pre_tasks</code> and <code>post_tasks</code> keywords. Normally, the tasks of roles execute before the tasks of a playbook. To control order of execution <code>pre_tasks</code> are performed before any roles are applied. The <code>post_tasks</code> are performed after all the roles have completed. Here we just use them to better highlight when the actual role is executed.</p> <p>Info</p> <p>In most use cases, you should not mix/use roles and tasks in your play together. If you need to have single tasks in your play, why not create another role and include the tasks there?!</p> <p>Now you are ready to run your playbook:</p> AnsibleNavigator <pre><code>[student@ansible-1 ansible-files]$ ansible-playbook test_apache_role.yml\n</code></pre> <pre><code>[student@ansible-1 ansible-files]$ ansible-navigator run test_apache_role.yml -m stdout\n</code></pre> <p>Run a curl command against <code>node2</code> to confirm that the role worked or use the <code>check_httpd.yml</code> playbook (you may need to adjust the variable in it to <code>node2:8080</code>):</p> <pre><code>[student@ansible-1 ansible-files]$ curl -s http://node2:8080\n&lt;body&gt;\n&lt;h1&gt;The virtual host configuration works!&lt;/h1&gt;\n&lt;/body&gt;\n</code></pre> <p>Warning</p> <p>If you are using the local development environment, remember, you are using containers instead of actual VMs! You need to append the correct port (e.g. <code>curl http://node1:8003\"</code> for Port 8080 of node1, or <code>curl http://node2:8006\"</code> for Port 8080 of node2). Take a look at the table with the ports overview or execute <code>podman ps</code> and check the output.</p> <p>You can also use the IP address of node2 (copy it from your inventory) and paste it into the browser (as well as adding <code>:8080</code>).</p> <p>Congratulations! You have successfully completed this exercise!</p>"},{"location":"ansible-core/ansible-core-roles/#troubleshooting-problems","title":"Troubleshooting problems","text":"<p>Did the final curl work? You can see what ports the web server is running on by using the netstat command, connect to the managed node via SSH:</p> <pre><code>#&gt; sudo netstat -tulpn\n</code></pre> <p>If netstat is not present, install it with this command:</p> <pre><code>#&gt; sudo dnf install -y net-tools\n</code></pre> <p>There should be a line like this:</p> <pre><code>tcp6       0      0 :::8080                 :::*                    LISTEN      25237/httpd\n</code></pre> <p>If it is not working, make sure that <code>/etc/httpd/conf/httpd.conf</code> has <code>Listen 8080</code> in it.  This should have been changed by Exercise 7.</p>"},{"location":"ansible-core/ansible-core-supplemental/","title":"Bonus exercises","text":"<p>You have finished the lab already. But it doesn\u2019t have to end here. We prepared some slightly more advanced bonus labs for you to follow through if you like. So if you are done with the labs and still have some time, here are some more labs for you:</p>"},{"location":"ansible-core/ansible-core-supplemental/#bonus-lab-1-prepare-infrastructure","title":"Bonus Lab 1: Prepare infrastructure","text":"<p>Ansible uses SSH to communicate with Linux nodes, the recommended method is to use SSH-Keys and not use a password to connect to the managed nodes. It is also advisable to use a dedicated user for automation on all managed nodes. In our exercises this user will be called <code>ansible</code>.  </p> <p>Let's break the initially working (password-less) SSH-connection in the lab environment and establish a new one with the service user <code>ansible</code>.</p> <p>Download a script using the next command. Copy the command by clicking the copy button on the right of the code block:</p> <pre><code>wget -q https://raw.githubusercontent.com/TimGrt/prepare-redhat-demo-system/master/break-ssh.sh\n</code></pre> <p>After downloading the script to your home directory, execute it:</p> <pre><code>[student@ansible-1 ~]$ wget -q https://raw.githubusercontent.com/TimGrt/prepare-redhat-demo-system/master/break-ssh.sh\n[student@ansible-1 ~]$ sh break-ssh.sh\n[student@ansible-1 ~]$\n</code></pre> <p>No output is good output. Now we can configure the SSH connection the way it want.</p> <p>Success</p> <p>The goal is to be able to communicate from ansible-1 as <code>student</code> to the <code>ansible</code> user on all 3 managed nodes.</p> <p>We will need the (already present) SSH public key of user <code>student</code> on ansible-1 (use your own, not this one!):</p> <pre><code>[student@ansible-1 ~]$ cat .ssh/id_rsa.pub\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCFeZ0j9HODBeDzP5aV5mkrsIGY1mvHTLjbCZIeHNpldIGETKflG6W0/\n...\n</code></pre> Hint <p>If you want to create your own SSH-Key-Pair, use this command: <pre><code>ssh-keygen\n</code></pre></p> <p>Next, SSH to the ec2-user on node1.</p> <pre><code>[student@ansible-1 ~]$ ssh ec2-user@node1\n[ec2-user@node1 ~]$\n</code></pre> <p>Your are now on node1. Switch to the root user and create a new user <code>ansible</code> (with a home directory). After creating the user, switch to the <code>ansible</code> user:</p> <pre><code>[ec2-user@node1 ~]$ sudo su - root\nLast login: Sun Apr 17 08:36:53 UTC 2022 on pts/0\n[root@node1 ~]# useradd ansible\n[root@node1 ~]# su - ansible\n[ansible@node1 ~]$\n</code></pre> <p>Ensure that you are the ansible user, we need to create the (hidden) <code>.ssh</code> directory and the <code>authorized_keys</code> file in it. The <code>authorized_keys</code> file houses the public key of user student on the ansible-1 host, copy the key to the file (press i in vi to enter the insert mode):</p> <pre><code>[ansible@node1 ~]$ mkdir .ssh\n[ansible@node1 ~]$ vi .ssh/authorized_keys\n</code></pre> <p>Now we have to set the correct permissions, the <code>.ssh</code> directory needs 0700, the <code>authorized_keys</code> file needs 0600.</p> <pre><code>[ansible@node1 ~]$ chmod 0700 .ssh\n[ansible@node1 ~]$ chmod 0600 .ssh/authorized_keys\n</code></pre> <p>Good! We now have established a service user for our automation. The user must be able to do root-like tasks e.g. installing and starting services, therefore he needs sudo permissions. Switch back to the root user by entering <code>exit</code>, you are still on node1.</p> <p>Warning</p> <p>Clobbering the sudoers file is one of the fastest ways to make your host unusable. Whenever you deal with suoders files, use <code>visudo</code>!</p> <p>As the root user, create a new file under <code>/etc/sudoers.d</code>:</p> <pre><code>[root@node1 ~]$ visudo -f /etc/sudoers.d/automation\n</code></pre> <p>Copy the following line which enables the <code>ansible</code> user to use password-less sudo (use the copy button of the code block again):</p> <pre><code>ansible ALL=(ALL) NOPASSWD:ALL\n</code></pre> <p>We can check if the <code>ansible</code> user has the required permissions:</p> <pre><code>[root@node1 ~]# sudo -l -U ansible\nMatching Defaults entries for ansible on node1:\n    !visiblepw, always_set_home, match_group_by_gid, always_query_group_plugin, env_reset, env_keep=\"COLORS DISPLAY HOSTNAME HISTSIZE KDEDIR LS_COLORS\", env_keep+=\"MAIL PS1 PS2 QTDIR USERNAME LANG LC_ADDRESS LC_CTYPE\", env_keep+=\"LC_COLLATE LC_IDENTIFICATION LC_MEASUREMENT LC_MESSAGES\",\n    env_keep+=\"LC_MONETARY LC_NAME LC_NUMERIC LC_PAPER LC_TELEPHONE\", env_keep+=\"LC_TIME LC_ALL LANGUAGE LINGUAS _XKB_CHARSET XAUTHORITY\", secure_path=/sbin\\:/bin\\:/usr/sbin\\:/usr/bin, !requiretty\n\nUser ansible may run the following commands on node1:\n    (ALL) NOPASSWD: ALL\n</code></pre> <p>Log out of node1 (ensure that you are back on your ansible master node ansible-1, run <code>exit</code> twice) and try to log in to node1 with the ansible user:</p> <pre><code>[student@ansible-1 ~]$ ssh ansible@node1\n[ansible@node1 ~]$\n</code></pre> <p>Failure</p> <p>If password-less SSH is not working, check the permissions of the <code>.ssh</code> folder and the <code>authorized_keys</code> file on the target host!</p> <p>Success</p> <p>Repeat the steps above for node2 and node3!</p> <p>Once you can reach all managed nodes password-less (and sudo-permissions are set, you will need this later), we can start to do some Ansible stuff like executing this Ad-hoc command:</p> <pre><code>[student@ansible-1 ~]$ ansible web -m ping\n</code></pre> <p>We got an error, all three nodes aren't reachable?! But manually, we can reach all nodes via SSH! Observing the error message we can see what the problem is, Ansible tries to us reach all hosts as the student user. We established the service user ansible for that, we must instruct Ansible to use that user. By default, Ansible will use the user that is executing the ansible commands.</p> <p>Open the Ansible inventory file, either by clicking the lab_inventory folder and the hosts file in the VScode explorer or on the terminal. Create a new variable section (with :vars) for the web group and set the ansible_user=ansible variable:</p> <pre><code>[web]\nnode1 ansible_host=&lt;X.X.X.X&gt;\nnode2 ansible_host=&lt;Y.Y.Y.Y&gt;\nnode3 ansible_host=&lt;Z.Z.Z.Z&gt;\n\n[web:vars]\nansible_user=ansible\n\n[control]\nansible-1 ansible_host=44.55.66.77\n</code></pre> <p>All hosts in the web group will now use the ansible user for the SSH connection. Try with the ad hoc command again:</p> <pre><code>[student@ansible-1 ~]$ ansible web -m ping\nnode2 | SUCCESS =&gt; {\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/libexec/platform-python\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\nnode3 | SUCCESS =&gt; {\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/libexec/platform-python\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\nnode1 | SUCCESS =&gt; {\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/libexec/platform-python\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\n</code></pre> <p>Success! All three nodes are reachable, we get a pong back, we proved that we can establish a SSH connection and that the node(s) have a usable Python interpreter.</p> <p>Try to run the same ad hoc command against the control group.  </p> <pre><code>[student@ansible-1 ~]$ ansible control -m ping\n</code></pre> <p>An error again?? Although being on the same host, Ansible tries to open an SSH connection. Adjust the inventory file again and set the <code>ansible_connection</code> variable for the ansible-1 host:</p> <pre><code>[web]\nnode1 ansible_host=&lt;X.X.X.X&gt;\nnode2 ansible_host=&lt;Y.Y.Y.Y&gt;\nnode3 ansible_host=&lt;Z.Z.Z.Z&gt;\n\n[web:vars]\nansible_user=ansible\n\n[control]\nansible-1 ansible_host=44.55.66.77 ansible_connection=local\n</code></pre> <p>With <code>ansible_connection=local</code> (on host-level) Ansible uses the local Python interpreter, which is fine for our Ansible master node. Now the ad hoc command succeeds:</p> <pre><code>[student@ansible-1 ~]$ ansible control -m ping\nansible-1 | SUCCESS =&gt; {\n    \"ansible_facts\": {\n        \"discovered_interpreter_python\": \"/usr/libexec/platform-python\"\n    },\n    \"changed\": false,\n    \"ping\": \"pong\"\n}\n</code></pre>"},{"location":"ansible-core/ansible-core-supplemental/#bonus-lab-2-ad-hoc-commands","title":"Bonus Lab 2: Ad Hoc Commands","text":"<p>Create a new user \"testuser\" on <code>node1</code> and <code>node3</code> with a comment using an ad hoc command, make sure that it is not created on <code>node2</code>!</p> <ul> <li> <p>Find the parameters for the appropriate module using <code>ansible-doc user</code> (leave with <code>q</code>)</p> </li> <li> <p>Use an Ansible ad hoc command to create the user with the comment \"Test D User\"</p> </li> <li> <p>Use the \"command\" module with the proper invocation to find the userid</p> </li> <li> <p>Delete the user and its directories, then check that the user has been deleted</p> </li> </ul> <p>Tip</p> <p>Remember privilege escalation\u2026\u200b</p> Solution <p>Your commands could look like these:</p> <pre><code>[student@ansible-1 ansible-files]$ ansible-doc -l | grep -i user\n[student@ansible-1 ansible-files]$ ansible-doc user\n[student@ansible-1 ansible-files]$ ansible node1,node3 -m user -a \"name=testuser comment='Test D User'\" -b\n[student@ansible-1 ansible-files]$ ansible node1,node3 -m command -a \" id testuser\" -b\n[student@ansible-1 ansible-files]$ ansible node2 -m command -a \" id testuser\" -b\n[student@ansible-1 ansible-files]$ ansible node1,node3 -m user -a \"name=testuser state=absent remove=yes\" -b\n[student@ansible-1 ansible-files]$ ansible web -m command -a \" id testuser\" -b\n</code></pre>"},{"location":"ansible-core/ansible-core-supplemental/#bonus-lab-3-templates-and-variables","title":"Bonus Lab 3: Templates and Variables","text":"<p>You have learned the basics about Ansible templates, variables and handlers. Let\u2019s combine all of these.</p> <p>Instead of editing and copying <code>httpd.conf</code> why don\u2019t you just define a variable for the listen port and use it in a template? Here is your job:</p> <ul> <li> <p>Define a variable <code>listen_port</code> for the <code>web</code> group with the value <code>8080</code> and another for <code>node2</code> with the value <code>80</code> using the proper files.</p> </li> <li> <p>Copy the <code>httpd.conf</code> file into the template <code>httpd.conf.j2</code> that uses the <code>listen_port</code> variable instead of the hard-coded port number.</p> </li> <li> <p>Write a Playbook that deploys the template and restarts Apache on changes using a handler.</p> </li> <li> <p>Run the Playbook and test the result using <code>curl</code>.</p> </li> </ul> <p>Tip</p> <p>Remember the <code>group_vars</code> and <code>host_vars</code> directories? If not, refer to the chapter Using variables.</p> Solution <p>Define the variable.  Add this line to <code>group_vars/web</code>:</p> <pre><code>listen_port: 8080\n</code></pre> <p>Add this line to <code>host_vars/node2</code>:</p> <pre><code>listen_port: 80\n</code></pre> <p>Prepare the template:</p> <ul> <li> <p>Copy <code>httpd.conf</code> to <code>httpd.conf.j2</code></p> </li> <li> <p>Edit the \"Listen\" directive in <code>httpd.conf.j2</code> to make it look like this:</p> </li> </ul> <pre><code>Listen {{ listen_port }}\n</code></pre> <p>Create a playbook called <code>apache_config_tpl.yml</code>:</p> <pre><code>---\n- name: Apache httpd.conf deployment\n  hosts: web\n  become: true\n  tasks:\n    - name: Create Apache configuration file from template\n      ansible.builtin.template:\n        src: httpd.conf.j2\n        dest: /etc/httpd/conf/httpd.conf\n        mode: \"0644\"\n      notify:\n          - Restart_apache\n  handlers:\n      - name: Restart_apache\n        ansible.builtin.service:\n          name: httpd\n          state: restarted\n</code></pre> <p>First run the playbook itself, then run curl against <code>node1</code> with port <code>8080</code> and <code>node2</code> with port <code>80</code>.</p> <pre><code>[student@ansible-1 ansible-files]$ ansible-playbook apache_config_tpl.yml\n[...]\n[student@ansible-1 ansible-files]$ curl http://18.195.235.231:8080\n&lt;body&gt;\n&lt;h1&gt;This is a development webserver, have fun!&lt;/h1&gt;\n&lt;/body&gt;\n[student@ansible-1 ansible-files]$ curl http://35.156.28.209:80\n&lt;body&gt;\n&lt;h1&gt;This is a production webserver, take care!&lt;/h1&gt;\n&lt;/body&gt;\n</code></pre>"},{"location":"ansible-core/ansible-core-templates/","title":"8 - Templating with Jinja2","text":""},{"location":"ansible-core/ansible-core-templates/#objective","title":"Objective","text":"<p>This exercise will cover Jinja2 templating. Ansible uses Jinja2 templating to modify files before they are distributed to managed hosts. Jinja2 is one of the most used template engines for Python, take a look at the documentation for additional information.</p>"},{"location":"ansible-core/ansible-core-templates/#guide","title":"Guide","text":""},{"location":"ansible-core/ansible-core-templates/#step-1-using-templates-in-playbooks","title":"Step 1 - Using Templates in Playbooks","text":"<p>When a template for a file has been created, it can be deployed to the managed hosts using the <code>template</code> module, which supports the transfer of a local file from the control node to the managed hosts.</p> <p>As an example of using templates you will change the motd file to contain host-specific data.</p> <p>First create the directory <code>templates</code> to hold template resources in <code>~/ansible-files/</code>:</p> <pre><code>[student@ansible-1 ansible-files]$ mkdir templates\n</code></pre> <p>Then in the <code>~/ansible-files/templates/</code> directory create the template file <code>motd-facts.j2</code>:</p> <pre><code>Welcome to {{ ansible_hostname }}.\n{{ ansible_distribution }} {{ ansible_distribution_version}}\ndeployed on {{ ansible_architecture }} architecture.\n</code></pre> <p>The template file contains the basic text that will later be copied over. It also contains variables which will be replaced on the target machines individually.</p> <p>Next we need a playbook to use this template. In the <code>~/ansible-files/</code> directory create the Playbook <code>motd-facts.yml</code>:</p> <pre><code>---\n- name: Fill motd file with host data\n  hosts: node1\n  become: true\n  tasks:\n    - name: Deploy message of the day file\n      ansible.builtin.template:\n        src: motd-facts.j2\n        dest: /etc/motd\n        owner: root\n        group: root\n        mode: \"0644\"\n</code></pre> <p>As we just learned what handlers do, let's add one to this playbook. Add the handlers block with a simple task, which just outputs a message:</p> <pre><code>---\n- name: Fill motd file with host data\n  hosts: node1\n  become: true\n  handlers:\n    - name: Motd_changed\n      ansible.builtin.debug:\n        msg: \"The Message of the Day was updated! SSH to node1 and check the content.\"\n  tasks:\n    - name: Deploy message of the day file\n      ansible.builtin.template:\n        src: motd-facts.j2\n        dest: /etc/motd\n        owner: root\n        group: root\n        mode: \"0644\"\n</code></pre> <p>Before we do a bigger challenge lab, let's see if you remember how handlers are triggered. Currently, the handler is not triggered, add the missing keyword to the task, which deploys the template.</p> Solution <p>Add the notify keyword and the name of the handler:</p> <pre><code>---\n- name: Fill motd file with host data\n  hosts: node1\n  become: true\n  handlers:\n    - name: Motd_changed\n      ansible.builtin.debug:\n        msg: \"The Message of the Day was updated! SSH to node1 and check the content.\"\n  tasks:\n    - name: Deploy message of the day file\n      ansible.builtin.template:\n        src: motd-facts.j2\n        dest: /etc/motd\n        owner: root\n        group: root\n        mode: \"0644\"\n      notify: Motd_changed\n</code></pre> <p>You have done this a couple of times by now:</p> <ul> <li>Understand what the Playbook does.</li> <li>Execute the Playbook <code>motd-facts.yml</code>.</li> <li>Observe if the handler was triggered. Re-Run the playbook multiple times.</li> <li>Login to node1 via SSH and check the message of the day content.</li> <li>Log out of node1.</li> </ul> <p>You should see how Ansible replaces the variables with the facts it discovered from the system. The handler was only triggered when the task reported a changed state.</p>"},{"location":"ansible-core/ansible-core-templates/#step-2-challenge-lab","title":"Step 2 - Challenge Lab","text":"<p>Add a line to the template to list the current kernel of the managed node.</p> <ul> <li>Find a fact that contains the kernel version using the commands you learned in the \"Ansible Facts\" chapter.</li> </ul> <p>Tip</p> <p>Filter for kernel.</p> <p>Run the newly created playbook to find the fact name.</p> <ul> <li> <p>Change the template to use the fact you found.</p> </li> <li> <p>Run the motd playbook again.</p> </li> <li> <p>Check motd by logging in to node1</p> </li> </ul> Solution <p>Find the fact:</p> <pre><code>---\n- name: Capture Kernel Version\n  hosts: node1\n  tasks:\n    - name: Collect only kernel facts\n      ansible.builtin.setup:\n        filter:\n          - '*kernel'\n      register: setup_output\n\n    - name: Output variable content\n      ansible.builtin.debug:\n        msg: \"{{ setup_output }}\"\n</code></pre> <p>With the wildcard in place, the output shows:</p> <pre><code>TASK [debug] *******************************************************************\nok: [node1] =&gt; {\n    \"setup\": {\n        \"ansible_facts\": {\n            \"ansible_kernel\": \"4.18.0-305.12.1.el8_4.x86_64\"\n        },\n        \"changed\": false,\n        \"failed\": false\n    }\n}\n</code></pre> <p>With this we can conclude the variable we are looking for is labeled <code>ansible_kernel</code>. Then we can update the motd-facts.j2 template to include <code>ansible_kernel</code> as part of its message.</p> <p>Modify the template <code>motd-facts.j2</code>:</p> <pre><code>Welcome to {{ ansible_hostname }}!\nHost runs {{ ansible_distribution }} {{ ansible_distribution_version}}\nDeployed on {{ ansible_architecture }} architecture\nThe kernel version is {{ ansible_kernel }}\n</code></pre> <p>Run the playbook.</p> AnsibleNavigator <pre><code>[student@ansible-1 ~]$ ansible-playbook motd-facts.yml\n</code></pre> <pre><code>[student@ansible-1 ~]$ ansible-navigator run motd-facts.yml -m stdout\n</code></pre> <p>Verify the new message via SSH login to <code>node1</code>.</p> <pre><code>[student@ansible-1 ~]$ ssh node1\nWelcome to node1.\nHost runs RedHat 8.1\nDeployed on x86_64 architecture\nThe kernel version is 4.18.0-305.12.1.el8_4.x86_64.\n</code></pre>"},{"location":"ansible-core/ansible-core-variables/","title":"4 - Using Variables","text":""},{"location":"ansible-core/ansible-core-variables/#objective","title":"Objective","text":"<p>Ansible supports variables to store values that can be used in Ansible playbooks. Variables can be defined in a variety of places and have a clear precedence. Ansible substitutes the variable with its value when a task is executed.</p> <p>This exercise covers variables, specifically</p> <ul> <li>How to use variable delimiters <code>{{</code> and <code>}}</code></li> <li>What <code>host_vars</code> and <code>group_vars</code> are and when to use them</li> <li>How to use <code>ansible_facts</code></li> <li>How to use the <code>debug</code> module to print variables to the console window</li> </ul>"},{"location":"ansible-core/ansible-core-variables/#guide","title":"Guide","text":"<p>Variables are referenced in Ansible Playbooks by placing the variable name in double curly braces:</p> <pre><code>This string contains a {{ variable }}\n</code></pre> <p>Variables and their values can be defined in various places: the inventory, additional files, on the command line, etc.</p> <p>The recommended practice to provide variables in the inventory, is to define them in files located in two directories: <code>host_vars</code> and <code>group_vars</code>.</p> <ul> <li>To define variables for a group \"servers\", a YAML file named <code>group_vars/servers.yml</code> with the variable definitions is created.</li> <li>To define variables specifically for a host <code>node1</code>, the file <code>host_vars/node1.yml</code> with the variable definitions is created.</li> </ul> <p>Tip</p> <p>Host variables take precedence over group variables (more about precedence can be found in the docs).</p>"},{"location":"ansible-core/ansible-core-variables/#step-1-create-variable-files","title":"Step 1 - Create Variable Files","text":"<p>For understanding and practice let\u2019s do a lab. Following up on the theme \"Let\u2019s build a web server. Or two. Or even more\u2026\u200b\", you will change the <code>index.html</code> to show the development environment (dev/prod) a server is deployed in.</p> <p>On the ansible control host, as the <code>student</code> user, create the directories to hold the variable definitions in <code>~/ansible-files/</code>:</p> <pre><code>[student@ansible-1 ansible-files]$ mkdir host_vars group_vars\n</code></pre> <p>Now create two files containing variable definitions. We\u2019ll define a variable named <code>stage</code> which will point to different environments, <code>dev</code> or <code>prod</code>:</p> <ul> <li>Create the file <code>~/ansible-files/group_vars/web.yml</code> with this content:</li> </ul> <pre><code>---\nstage: dev\n</code></pre> <ul> <li>Create the file <code>~/ansible-files/host_vars/node2.yml</code> with this content:</li> </ul> <pre><code>---\nstage: prod\n</code></pre> <p>What is this about?</p> <ul> <li>For all servers in the <code>web</code> group the variable <code>stage</code> with value <code>dev</code> is defined. So as default we flag them as members of the dev environment.</li> <li>For server <code>node2</code> this is overridden and the host is flagged as a production server.</li> </ul>"},{"location":"ansible-core/ansible-core-variables/#step-2-create-webhtml-files","title":"Step 2 - Create web.html Files","text":"<p>Now create two files in <code>~/ansible-files/files/</code>:</p> <p>One called <code>prod_web.html</code> with the following content:</p> <pre><code>&lt;body&gt;\n&lt;h1&gt;This is a production webserver, take care!&lt;/h1&gt;\n&lt;/body&gt;\n</code></pre> <p>And the other called <code>dev_web.html</code> with the following content:</p> <pre><code>&lt;body&gt;\n&lt;h1&gt;This is a development webserver, have fun!&lt;/h1&gt;\n&lt;/body&gt;\n</code></pre>"},{"location":"ansible-core/ansible-core-variables/#step-3-create-the-playbook","title":"Step 3 - Create the Playbook","text":"<p>Now you need a Playbook that copies the prod or dev <code>web.html</code> file - according to the \"stage\" variable.</p> <p>Create a new Playbook called <code>deploy_index_html.yml</code> in the <code>~/ansible-files/</code> directory.</p> <p>Tip</p> <p>Note how the variable \"stage\" is used in the name of the file to copy.</p> <pre><code>---\n- name: Webserver configuration\n  hosts: web\n  become: true\n  tasks:\n    - name: Copy web.html\n      ansible.builtin.copy:\n        src: \"{{ stage }}_web.html\"\n        dest: /var/www/html/index.html\n        mode: \"0644\"\n        owner: apache\n        group: apache\n</code></pre> <ul> <li>Run the Playbook:</li> </ul> AnsibleNavigator <pre><code>[student@ansible-1 ansible-files]$ ansible-playbook deploy_index_html.yml\n</code></pre> <pre><code>[student@ansible-1 ansible-files]$ ansible-navigator run deploy_index_html.yml\n</code></pre>"},{"location":"ansible-core/ansible-core-variables/#step-4-test-the-result","title":"Step 4 - Test the Result","text":"<p>The Ansible Playbook copies different files as index.html to the hosts, use <code>curl</code> to test it.</p> <p>For node1:</p> <pre><code>[student@ansible-1 ansible-files]$ curl http://node1\n&lt;body&gt;\n&lt;h1&gt;This is a development webserver, have fun!&lt;/h1&gt;\n&lt;/body&gt;\n</code></pre> <p>For node2:</p> <pre><code>[student@ansible-1 ansible-files]$ curl http://node2\n&lt;body&gt;\n&lt;h1&gt;This is a production webserver, take care!&lt;/h1&gt;\n&lt;/body&gt;\n</code></pre> <p>For node3:</p> <pre><code>[student@ansible-1 ansible-files]$ curl http://node3\n&lt;body&gt;\n&lt;h1&gt;This is a development webserver, have fun!&lt;/h1&gt;\n&lt;/body&gt;\n</code></pre> <p>Tip</p> <p>If by now you think: There has to be a smarter way to change content in files\u2026\u200b you are absolutely right. This lab was done to introduce variables, you are about to learn about templates in one of the next chapters.</p>"},{"location":"ansible-core/ansible-core-variables/#step-5-ansible-facts","title":"Step 5 - Ansible Facts","text":"<p>Ansible facts are variables that are automatically discovered by Ansible from a managed host. Remember the \"Gathering Facts\" task with the setup module we used with the Ansible ad hoc command? The facts contain useful information stored into variables that administrators can reuse.</p> <p>To get an idea what facts Ansible collects by default, on your control node as your student user create the playbook <code>setup.yml</code> and run it to get the setup details of <code>node1</code>:</p> <pre><code>---\n- name: Capture and output facts\n  hosts: node1\n  gather_facts: false\n  tasks:\n    - name: Collect only facts returned by facter\n      ansible.builtin.setup:\n        gather_subset:\n          - 'all'\n      register: setup_output\n\n    - name: Output variable content\n      ansible.builtin.debug:\n        msg: \"{{ setup_output }}\"\n</code></pre> AnsibleNavigator <pre><code>[student@ansible-1 ansible-files]$ ansible-playbook setup.yml\n</code></pre> <pre><code>[student@ansible-1 ansible-files]$ ansible-navigator run setup.yml -m stdout\n</code></pre> <p>This might be a bit too much, you can use filters to limit the output to certain facts, the expression is shell-style wildcard within your playbook. Create a playbook labeled <code>setup_filter.yml</code> as shown below. In this example, we filter to get the <code>eth0</code> facts as well as memory details of <code>node1</code>.</p> <pre><code>---\n- name: Capture and output facts\n  hosts: node1\n  gather_facts: false\n  tasks:\n    - name: Collect only specific facts\n      ansible.builtin.setup:\n        filter:\n          - 'ansible_eth0'\n          - 'ansible_*_mb'\n      register: setup_output\n\n    - name: Output variable content\n      ansible.builtin.debug:\n        msg: \"{{ setup_output }}\"\n</code></pre> <p>Run the playbook:</p> AnsibleNavigator <pre><code>[student@ansible-1 ansible-files]$ ansible-playbook setup_filter.yml\n</code></pre> <pre><code>[student@ansible-1 ansible-files]$ ansible-navigator run setup_filter.yml -m stdout\n</code></pre>"},{"location":"ansible-core/ansible-core-variables/#step-6-challenge-lab-facts","title":"Step 6 - Challenge Lab: Facts","text":"<ul> <li>Try to find and print the OS family (RedHat) of your managed hosts using a playbook, it should output only this single fact.</li> </ul> <p>Tip</p> <p>Use an ad-hoc command to output all facts, maybe even filter the output by using <code>grep</code> to find the appropriate fact.</p> Solution <pre><code>$ ansible node1 -m setup | grep family\n    \"ansible_os_family\": \"RedHat\",\n</code></pre> <pre><code>---\n- name: Capture and output facts\n  hosts: node1\n  gather_facts: false\n  tasks:\n    - name: Collect only specific facts, this task can be removed when enabling 'gather_facts' again.\n      ansible.builtin.setup:\n        filter:\n          - '*family'\n      register: setup_output\n\n    - name: Output variable content\n      ansible.builtin.debug:\n        msg: \"{{ ansible_os_family }}\"\n</code></pre> <p>Run the playbook:</p> <pre><code>[student@ansible-1 ansible-files]$ ansible-playbook setup_filter.yml\n</code></pre> <p>Optionally, run the playbook with the ansible-navigator:</p> <pre><code>[student@ansible-1 ansible-files]$ ansible-navigator run setup_filter.yml -m stdout\n</code></pre>"},{"location":"ansible-core/ansible-core-variables/#step-7-using-facts-in-playbooks","title":"Step 7 - Using Facts in Playbooks","text":"<p>Facts can be used in a Playbook like variables, using the proper naming, of course. Create this Playbook as <code>facts.yml</code> in the <code>~/ansible-files/</code> directory:</p> <pre><code>---\n- name: Output facts within a playbook\n  hosts: all\n  tasks:\n    - name: Prints Ansible facts\n      ansible.builtin.debug:\n        msg: From a total of {{ ansible_memtotal_mb }} MB the server {{ ansible_fqdn }} has {{ ansible_memfree_mb }} MB RAM left.\n</code></pre> <p>Tip</p> <p>The \"debug\" module is handy for e.g. debugging variables or expressions.</p> <p>Execute it to see how the facts are printed:</p> AnsibleNavigator <pre><code>[student@ansible-1 ansible-files]$ ansible-playbook facts.yml\n</code></pre> <pre><code>[student@ansible-1 ansible-files]$ ansible-navigator run facts.yml -m stdout\n</code></pre> <p>Examine the output:</p> <pre><code>PLAY [Output facts within a playbook] ******************************************************************************\n\nTASK [Gathering Facts] *********************************************************************************************\nok: [node2]\nok: [node3]\nok: [node1]\nok: [ansible-1]\n\nTASK [Prints Ansible facts] ****************************************************************************************\nok: [ansible-1] =&gt; {\n    \"msg\": \"From a total of 7937 MB the server ansible-1 has 2856 MB RAM left.\"\n}\nok: [node1] =&gt; {\n    \"msg\": \"From a total of 7937 MB the server node1 has 3152 MB RAM left.\"\n}\nok: [node2] =&gt; {\n    \"msg\": \"From a total of 7937 MB the server node2 has 3138 MB RAM left.\"\n}\nok: [node3] =&gt; {\n    \"msg\": \"From a total of 7937 MB the server node3 has 3247 MB RAM left.\"\n}\n\nPLAY RECAP *********************************************************************************************************\nansible-1                  : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0  \nnode1                      : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0  \nnode2                      : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0  \nnode3                      : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0  \n</code></pre>"},{"location":"ansible-navigator/ansible-navigator/","title":"Ansible Navigator","text":""},{"location":"ansible-navigator/ansible-navigator/#objective","title":"Objective","text":"<p>In this exercise, we are going to explore the latest Ansible command line utility <code>ansible-navigator</code> to learn how to work with inventory files and the listing of modules when needing assistance. The goal is to familiarize yourself with how <code>ansible-navigator</code> works and how it can be used to enrich your Ansible experience.</p> <p>This exercise will cover</p> <ul> <li>Working with inventory files</li> <li>Locating and understanding an <code>ini</code> formatted inventory file</li> <li>Listing modules and getting help when trying to use them</li> </ul>"},{"location":"ansible-navigator/ansible-navigator/#guide","title":"Guide","text":"<p>With the introduction of Ansible Automation Platform 2, several new key components are being introduced as a part of the overall developer experience. Execution environments have been introduced to provide predictable environments to be used during automation runtime. All collection dependencies are contained within the execution environment to ensure that automation created in development environments runs the same as in production environments.</p> <p>What do you find within an execution environment?</p> <ul> <li>RHEL UBI 8</li> <li>Ansible 2.9 or Ansible Core 2.11</li> <li>Python 3.8</li> <li>Any content Collections</li> <li>Collection python or binary dependencies.</li> </ul> <p>Why use execution environments?</p> <p>They provide a standardized way to define, build and distribute the environments that the automation runs in. In a nutshell, Automation execution environments are container images that allow for easier administration of Ansible by the platform administrator.</p> <p>Considering the shift towards containerized execution of automation, automation development workflow and tooling that existed before Ansible Automation Platform 2 have had to be re-imagined. In short, <code>ansible-navigator</code> replaces <code>ansible-playbook</code> and other <code>ansible-*</code> command line utilities.</p> <p>With this change, Ansible playbooks are executed using the <code>ansible-navigator</code> command on the control node.</p> <p>The prerequisites and best practices for using <code>ansible-navigator</code> have been done for you within this lab.</p> <p>These include:</p> <ul> <li>Installing the <code>ansible-navigator</code> package</li> <li>Creating a default settings <code>/home/student/.ansible-navigator.yml</code> for all your projects (optional)</li> <li>All execution environment (EE) logs are stored within <code>/home/student/.ansible-navigator/logs/ansible-navigator.log</code></li> <li>Playbook artifacts are saved under <code>/tmp/artifact.json</code></li> </ul> <p>Follow the next link for more information on the Ansible navigator settings.</p> <p>Tip</p> <p>The parameters for ansible-navigator maybe modified for your specific environment. The current settings use a default <code>ansible-navigator.yml</code> for all projects, but a specific <code>ansible-navigator.yml</code> can be created for each project and is the recommended practice.</p> <p>A useful ansible-navigator-configuration for the workshop environment is the following, create a new file in your project directory <code>/home/student/ansible-files/ansible-navigator.yml</code> and paste in this configuration:</p> <pre><code>---\nansible-navigator:\n  ansible:\n# Specify an inventory file path or comma separated host list\n    inventories:\n      - /home/student/lab_inventory/hosts\n# Sets configuration for  the creation of artifacts for completed playbooks.\n# Can be enabled or disabled and specify filename and location\n  playbook-artifact:\n    enable: true\n    save-as: ~/ansible-files/artifacts/{playbook_name}-artifact-{ts_utc}.json\n# Set user interface mode, either 'stdout' or 'interactive'\n# Mode 'stdout' ensures same output method as with ansible-playbook command\n  mode: interactive\n\n# Enable or disable the use of an execution environment and specify different options\n  execution-environment:\n    image: registry.redhat.io/ansible-automation-platform-20-early-access/ee-supported-rhel8:2.0.0\n    enabled: true\n    container-engine: podman\n    pull-policy: missing\n    volume-mounts:\n      - src: \"/etc/ansible/\"\n        dest: \"/etc/ansible/\"\n</code></pre> <p>Adjust the path to your inventory file, as well as the used container image if a newer image is used in the default ansible-navigator-configuration.</p>"},{"location":"ansible-navigator/ansible-navigator/#step-1-work-with-your-inventory","title":"Step 1 - Work with your Inventory","text":"<p>An inventory file is a text file that specifies the nodes that will be managed by the control machine. The nodes to be managed may include a list of hostnames or IP addresses of those nodes. The inventory file allows for nodes to be organized into groups by declaring a host group name within square brackets ([]).</p> <p>To use the <code>ansible-navigator</code> command for host management, you need to provide an inventory file which defines a list of hosts to be managed from the control node. In this lab, the inventory is provided by your instructor. The inventory file is an <code>ini</code> formatted file listing your hosts, sorted in groups, additionally providing some variables. It looks like:</p> <pre><code>[web]\nnode1 ansible_host=&lt;X.X.X.X&gt;\nnode2 ansible_host=&lt;Y.Y.Y.Y&gt;\nnode3 ansible_host=&lt;Z.Z.Z.Z&gt;\n\n[control]\nansible-1 ansible_host=44.55.66.77\n</code></pre> <p>Ansible is already configured to use the inventory specific to your environment. We will show you in the next step how that is done. For now, we will execute some simple commands to work with the inventory.</p> <p>To reference all the inventory hosts, you supply a pattern to the <code>ansible-navigator</code> command. <code>ansible-navigator inventory</code> has a <code>--list</code> option which can be useful for displaying all the hosts that are part of an inventory file including what groups they are associated with.</p> NavigatorAnsible <pre><code>[student@ansible-1 ~]$ ansible-navigator inventory --list -m stdout\n{\n    \"_meta\": {\n        \"hostvars\": {\n            \"ansible-1\": {\n                \"ansible_host\": \"3.236.186.92\"},\n            \"node1\": {\n                \"ansible_host\": \"3.239.234.187\"\n            },\n            \"node2\": {\n                \"ansible_host\": \"75.101.228.151\"\n            },\n            \"node3\": {\n                \"ansible_host\": \"100.27.38.142\"\n            }\n        }\n    },\n    \"all\": {\n        \"children\": [\n            \"control\",\n            \"ungrouped\",\n            \"web\"\n        ]\n    },\n    \"control\": {\n        \"hosts\": [\n            \"ansible-1\"\n        ]\n    },\n    \"web\": {\n        \"hosts\": [\n            \"node1\",\n            \"node2\",\n            \"node3\"\n        ]\n    }\n}\n</code></pre> <pre><code>[student@ansible-1 ~]$ ansible-inventory --list\n{\n    \"_meta\": {\n        \"hostvars\": {\n            \"ansible-1\": {\n                \"ansible_host\": \"3.236.186.92\"},\n            \"node1\": {\n                \"ansible_host\": \"3.239.234.187\"\n            },\n            \"node2\": {\n                \"ansible_host\": \"75.101.228.151\"\n            },\n            \"node3\": {\n                \"ansible_host\": \"100.27.38.142\"\n            }\n        }\n    },\n    \"all\": {\n        \"children\": [\n            \"control\",\n            \"ungrouped\",\n            \"web\"\n        ]\n    },\n    \"control\": {\n        \"hosts\": [\n            \"ansible-1\"\n        ]\n    },\n    \"web\": {\n        \"hosts\": [\n            \"node1\",\n            \"node2\",\n            \"node3\"\n        ]\n    }\n}\n</code></pre> <p>Note</p> <p><code>-m</code> is short for <code>--mode</code> which allows for the mode to be switched to standard output instead of using the text-based user interface (TUI).</p> <p>If the <code>--list</code> is too verbose, the option of <code>--graph</code> can be used to provide a more condensed version of <code>--list</code>.</p> NavigatorAnsible <pre><code>[student@ansible-1 ~]$ ansible-navigator inventory --graph -m stdout\n@all:\n|--@control:\n|  |--ansible-1\n|--@ungrouped:\n|--@web:\n|  |--node1\n|  |--node2\n|  |--node3\n</code></pre> <pre><code>[student@ansible-1 ~]$ ansible-inventory --graph\n@all:\n|--@control:\n|  |--ansible-1\n|--@ungrouped:\n|--@web:\n|  |--node1\n|  |--node2\n|  |--node3\n</code></pre> <p>We can clearly see that nodes: <code>node1</code>, <code>node2</code>, <code>node3</code> are part of the <code>web</code> group, while <code>ansible-1</code> is part of the <code>control</code> group.</p> <p>An inventory file can contain a lot more information, it can organize your hosts in groups or define variables. In our example, the current inventory has the groups <code>web</code> and <code>control</code>. Run Ansible with these host patterns and observe the output:</p> <p>Using the <code>ansible-navigator inventory</code> command, we can also run commands that provide information only for one host or group. For example, give the following commands a try to see their output.</p> <pre><code>[student@ansible-1 ~]$ ansible-navigator inventory --graph web -m stdout\n[student@ansible-1 ~]$ ansible-navigator inventory --graph control -m stdout\n[student@ansible-1 ~]$ ansible-navigator inventory --host node1 -m stdout\n</code></pre> <p>Tip</p> <p>The inventory can contain more data. E.g. if you have hosts that run on non-standard SSH ports you can put the port number after the hostname with a colon. Or you could define names specific to Ansible and have them point to the \"real\" IP or hostname.</p>"},{"location":"ansible-navigator/ansible-navigator/#step-2-listing-modules-and-getting-help","title":"Step 2 - Listing Modules and Getting Help","text":"<p>Ansible Automation Platform comes with multiple supported Execution Environments (EEs).  These EEs come with bundled supported collections that contain supported content, including modules.  To browse your available modules first enter interactive mode:</p> <pre><code>ansible-navigator\n</code></pre> <p></p> <p>Tip</p> <p>In <code>ansible-navigator</code> exit by pressing the button <code>ESC</code>.</p> <p>First browse a collection by typing <code>:collections</code></p> <pre><code>:collections\n</code></pre> <p></p> <p>To browse the content for a specific collections, type the corresponding number.  For example in the example screenshot above the number <code>0</code> corresponds to <code>amazon.aws</code> collection.  To zoom into collection type the number <code>0</code>.</p> <pre><code>0\n</code></pre> <p></p> <p>Get help for a specific module including usage by zooming in further.  For example the module <code>ec2_tag</code> corresponds to <code>24</code>.</p> <pre><code>:24\n</code></pre> <p>Scrolling down using the arrow keys or page-up and page-down can show us documentation and examples.</p> <p></p> <p>You can also skip directly to a particular module by simply typing <code>:doc namespace.collection.module-name</code>.  For example typing <code>:doc amazon.aws.ec2_tag</code> would skip directly to the final page shown above.</p> <p>Tip</p> <p>Different execution environments can have access to different collections, and different versions of those collections.  By using the built-in documentation you know that it will be accurate for that particular version of the collection.</p>"},{"location":"ansible-navigator/ansible-navigator/#step-3-examining-execution-environments","title":"Step 3 - Examining Execution Environments","text":"<p>Run the <code>ansible-navigator</code> command with the <code>images</code> argument to look at execution environments configured on the control node:</p> <pre><code>ansible-navigator images\n</code></pre> <p></p> <p>Note</p> <p>The output  you see might differ from the above output</p> <p>This command gives you information about all currently installed Execution Environments or EEs for short.  Investigate an EE by pressing the corresponding number.  For example pressing 2 with the above example will open the <code>ee-supported-rhel8</code> execution environment:</p> <p></p> <p>Selecting <code>2</code> for <code>Ansible version and collections</code> will show us all Ansible Collections installed on that particular EE, and the version of <code>ansible-core</code>:</p> <p></p>"},{"location":"ansible-navigator/ansible-navigator/#step-4-examining-the-ansible-navigator-configuration","title":"Step 4 - Examining the ansible-navigator configuration","text":"<p>Either use Visual Studio Code to open or use the <code>cat</code> command to view the contents of the <code>ansible-navigator.yml</code> file.  The file is located in the home directory:</p> <pre><code>$ cat ~/.ansible-navigator.yml\n---\nansible-navigator:\n  ansible:\n    inventories:\n    - /home/student/lab_inventory/hosts\n\n  execution-environment:\n    image: registry.redhat.io/ansible-automation-platform-20-early-access/ee-supported-rhel8:2.0.0\n    enabled: true\n    container-engine: podman\n    pull-policy: missing\n    volume-mounts:\n    - src: \"/etc/ansible/\"\n      dest: \"/etc/ansible/\"\n</code></pre> <p>Note the following parameters within the <code>ansible-navigator.yml</code> file:</p> <ul> <li><code>inventories</code>: shows the location of the ansible inventory being used</li> <li><code>execution-environment</code>: where the default execution environment is set</li> </ul> <p>For a full listing of every configurable knob checkout the documentation.</p>"},{"location":"ansible-navigator/ansible-navigator/#step-3-running-the-playbook","title":"Step 3 - Running the Playbook","text":"<p>Create a simple playbook:</p> <pre><code>---\n- name: Apache server installation\n  hosts: node1\n  become: true\n  tasks:\n    - name: Ensure Apache package is installed\n      ansible.builtin.package:\n        name: httpd\n        state: present\n</code></pre> <p>To run your playbook, use the <code>ansible-navigator run &lt;playbook&gt;</code> command as follows:</p> <pre><code>[student@ansible-1 ansible-files]$ ansible-navigator run apache.yml\n</code></pre> <p>Tip</p> <p>The existing <code>ansible-navigator.yml</code> file provides the location of your inventory file. If this was not set within your <code>ansible-navigator.yml</code> file, the command to run the playbook would be: <code>ansible-navigator run apache.yml -i /home/student/lab_inventory/hosts</code></p> <p>When running the playbook, you'll be displayed a text user interface (TUI) that displays the play name among other information about the playbook that is currently run.</p> <pre><code>  PLAY NAME                        OK  CHANGED    UNREACHABLE      FAILED    SKIPPED    IGNORED    IN PROGRESS     TASK COUNT          PROGRESS\n0\u2502Apache server installed           2        1              0           0          0          0              0              2          COMPLETE\n</code></pre> <p>If you notice, prior to the play name <code>Apache server installed</code>, you'll see a <code>0</code>. By pressing the <code>0</code> key on your keyboard, you will be provided a new window view displaying the different tasks that ran for the playbook completion. In this example, those tasks included the \"Gathering Facts\" and \"latest Apache version installed\". The \"Gathering Facts\" is a built-in task that runs automatically at the beginning of each play. It collects information about the managed nodes. Exercises later on will cover this in more detail. The \"latest Apache version installed\" was the task created within the <code>apache.yml</code> file that installed <code>httpd</code>.</p> <p>The display should look something like this:</p> <pre><code>  RESULT   HOST    NUMBER   CHANGED   TASK                              TASK ACTION    DURATION\n0\u2502OK       node1   0        False     Gathering Facts                   gather_facts   1s\n1\u2502OK       node1   1        False     latest Apache version installed   package            4s\n</code></pre> <p>Taking a closer look, you'll notice that each task is associated with a number. Task 1, \"latest Apache version installed\", does not show a change state, you already installed Apache yesterday, otherwise it would show a change.</p> <p>By pressing <code>0</code> or <code>1</code> on your keyboard, you can see further details of the task being run. If a more traditional output view is desired, type <code>:st</code> within the text user interface.</p> <p>Once you've completed, reviewing your Ansible playbook, you can exit out of the TUI via the Esc key on your keyboard.</p> <p>Tip</p> <p>The Esc key only takes you back to the previous screen. Once at the main overview screen an additional Esc key will take you back to the terminal window.</p> <p>Once the playbook has completed, connect to <code>node1</code> via SSH to make sure Apache has been installed. You may also skip this, as you did this yesterday.</p> <pre><code>[student@ansible-1 ansible-files]$ ssh node1\nLast login: Wed May 15 14:03:45 2019 from 44.55.66.77\nManaged by Ansible\n</code></pre> <p>Use the command <code>rpm -qi httpd</code> to verify httpd is installed:</p> <pre><code>[ec2-user@node1 ~]$ rpm -qi httpd\nName        : httpd\nVersion     : 2.4.37\n[...]\n</code></pre> <p>Log out of <code>node1</code> with the command <code>exit</code> so that you are back on the control host and verify the installed package with an Ansible playbook labeled <code>package.yml</code></p> <pre><code>---\n- name: Check packages\n  hosts: node1\n  become: true\n  vars:\n    package: \"httpd\"\n  tasks:\n    - name: Gather the package facts\n      ansible.builtin.package_facts:\n        manager: auto\n\n    - name: Output message if package is installed\n      ansible.builtin.debug:\n        msg: \"{{ package }} in Version {{ ansible_facts.packages[package][0].version }} is installed!\"\n</code></pre> <pre><code>[student@ansible-1 ~]$ ansible-navigator run package.yml -m stdout\n</code></pre> <pre><code>PLAY [Check packages] **********************************************************\nTASK [Gathering Facts] *********************************************************\nok: [ansible]\nTASK [Gather the package facts] ************************************************\nok: [ansible]\nTASK [Check whether a httpd  is installed] *************************************\nok: [ansible] =&gt; {\n    \"msg\": \"httpd 2.4.37 is installed!\"\n}\nPLAY RECAP *********************************************************************\nansible                    : ok=3    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0  \n</code></pre>"},{"location":"ansible-navigator/ansible-navigator/#step-5-extend-your-playbook-create-an-webhtml","title":"Step 5 - Extend your Playbook: Create an web.html","text":"<p>Check that the tasks were executed correctly and Apache is accepting connections: Make an HTTP request using Ansible\u2019s <code>uri</code> module in a playbook named check_httpd.yml from the control node to <code>node1</code>.</p> <pre><code>---\n- name: Check URL\n  hosts: control\n  vars:\n    node: \"node1\"\n  tasks:\n    - name: Check that you can connect (GET) to a page and it returns a status 200\n      ansible.builtin.uri:\n        url: \"http://{{ node }}\"\n</code></pre> <p>Warning</p> <p>Expect a lot of red lines and a 403 status!</p> <pre><code>[student@ansible-1 ~]$ ansible-navigator run check_httpd.yml -m stdout\n</code></pre> <p>There are a lot of red lines and an error: As long as there is not at least an <code>web.html</code> file to be served by Apache, it will throw an ugly \"HTTP Error 403: Forbidden\" status and Ansible will report an error.</p> <p>So why not use Ansible to deploy a simple <code>web.html</code> file? On the ansible control host, as the <code>student</code> user, create the directory <code>files</code> to hold file resources in <code>~/ansible-files/</code>:</p> <pre><code>[student@ansible-1 ansible-files]$ mkdir files\n</code></pre> <p>Then create the file <code>~/ansible-files/files/web.html</code> on the control node:</p> <pre><code>&lt;body&gt;\n&lt;h1&gt;Apache is running fine&lt;/h1&gt;\n&lt;/body&gt;\n</code></pre> <p>In a previous example, you used Ansible\u2019s <code>copy</code> module to write text supplied on the command line into a file. Now you\u2019ll use the module in your playbook to copy a file.</p> <p>On the control node as your student user edit the file <code>~/ansible-files/apache.yml</code> and add a new task utilizing the <code>copy</code> module. It should now look like this:</p> <pre><code>---\n- name: Apache server installation\n  hosts: node1\n  become: true\n  tasks:\n    - name: Install Apache package\n      ansible.builtin.package:\n        name: httpd\n        state: present\n\n    - name: Ensure Apache is enabled and running\n      ansible.builtin.service:\n        name: httpd.service\n        enabled: true\n        state: started\n\n    - name: Copy file for webserver index\n      ansible.builtin.copy:\n        src: web.html\n        dest: /var/www/html/index.html\n        mode: \"0644\"\n</code></pre> <p>What does this new copy task do? The new task uses the <code>copy</code> module and defines the source and destination options for the copy operation as parameters.</p> <p>Run your extended Playbook:</p> <pre><code>[student@ansible-1 ansible-files]$ ansible-navigator run apache.yml -m stdout\n</code></pre> <ul> <li> <p>Have a good look at the output, notice the changes of \"CHANGED\" and the tasks associated with that change.</p> </li> <li> <p>Run the Ansible playbook check_httpd.yml using the \"uri\" module from above again to test Apache. The command should now return a friendly green \"status: 200\" line, amongst other information.</p> </li> </ul>"},{"location":"ansible-navigator/ansible-navigator/#step-6-practice-apply-to-multiple-host","title":"Step 6 - Practice: Apply to Multiple Host","text":"<p>While the above, shows the simplicity of applying changes to a particular host. What about if you want to set changes to many hosts? This is where you'll notice the real power of Ansible as it applies the same set of tasks reliably to many hosts.</p> <ul> <li>So what about changing the apache.yml Playbook to run on <code>node1</code> and <code>node2</code> and <code>node3</code>?</li> </ul> <p>As you might remember, the inventory lists all nodes as members of the group <code>web</code>:</p> <pre><code>[web]\nnode1 ansible_host=node1.example.com\nnode2 ansible_host=node2.example.com\nnode3 ansible_host=node3.example.com\n</code></pre> <p>Change the playbook <code>hosts</code> parameter to point to <code>web</code> instead of <code>node1</code>:</p> <pre><code>---\n- name: Apache server installation\n  hosts: web\n  become: true\n  tasks:\n    - name: Install Apache package\n      ansible.builtin.package:\n        name: httpd\n        state: present\n\n    - name: Ensure Apache is enabled and running\n      ansible.builtin.service:\n        name: httpd.service\n        enabled: true\n        state: started\n\n    - name: Copy file for webserver index\n      ansible.builtin.copy:\n        src: web.html\n        dest: /var/www/html/index.html\n        mode: \"0644\"\n</code></pre> <p>Now run the playbook:</p> <pre><code>[student@ansible-1 ansible-files]$ ansible-navigator run apache.yml -m stdout\n</code></pre> <p>Verify if Apache is now running on all web servers (node1, node2, node3). All output should be green.</p>"},{"location":"automation-platform/automation-platform-intro/","title":"1 - AAP Introduction","text":""},{"location":"automation-platform/automation-platform-intro/#objective","title":"Objective","text":"<p>The following exercise will provide an Ansible automation controller overview including going through features that are provided by the Red Hat Ansible Automation Platform.  This will cover automation controller fundamentals such as:</p> <ul> <li>Job Templates</li> <li>Projects</li> <li>Inventories</li> <li>Credentials</li> <li>Workflows</li> </ul>"},{"location":"automation-platform/automation-platform-intro/#guide","title":"Guide","text":""},{"location":"automation-platform/automation-platform-intro/#why-ansible-automation-controller","title":"Why Ansible automation controller?","text":"<p>Automation controller is a web-based UI that provides an enterprise solution for IT automation. It</p> <ul> <li>has a user-friendly dashboard.</li> <li>complements Ansible, adding automation, visual management, and monitoring capabilities.</li> <li>provides user access control to administrators.</li> <li>provides distinct view and edit perspectives for automation controller objects and components.</li> <li>graphically manages or synchronizes inventories with a wide variety of sources.</li> <li>has a RESTful API.</li> <li>And much more...</li> </ul>"},{"location":"automation-platform/automation-platform-intro/#your-ansible-automation-controller-lab-environment","title":"Your Ansible automation controller lab environment","text":"<p>In this lab you work in a pre-configured lab environment. You will have access to the following hosts:</p> Role Inventory name Ansible control host &amp; automation controller ansible-1 Managed Host 1 node1 Managed Host 2 node2 Managed Host 2 node3 <p>The Ansible automation controller provided in this lab is individually setup for you. Make sure to access the right machine whenever you work with it. Automation controller has already been installed and licensed for you, the web UI will be reachable over HTTP/HTTPS.</p>"},{"location":"automation-platform/automation-platform-intro/#dashboard","title":"Dashboard","text":"<p>Let's have a first look at the automation controller: Point your browser to the URL you were given, similar to <code>https://demo.redhat.com/workshop/pm6xgd</code> (the  current workshop ID will be different) and log in as <code>admin</code>. The password will be provided by the instructor.</p> <p>The web UI of automation controller greets you with a dashboard with a graph showing:</p> <ul> <li>recent job activity</li> <li>the number of managed hosts</li> <li>quick pointers to lists of hosts with problems.</li> </ul> <p>The dashboard also displays real time data about the execution of tasks completed in playbooks.</p> <p></p>"},{"location":"automation-platform/automation-platform-intro/#concepts","title":"Concepts","text":"<p>Before we dive further into using Ansible automation controller, you should get familiar with some concepts and naming conventions.</p>"},{"location":"automation-platform/automation-platform-intro/#projects","title":"Projects","text":"<p>Projects are logical collections of Ansible playbooks in Ansible automation controller. These playbooks either reside on the Ansible automation controller instance, or in a source code version control system supported by automation controller.</p>"},{"location":"automation-platform/automation-platform-intro/#inventories","title":"Inventories","text":"<p>An Inventory is a collection of hosts against which jobs may be launched, the same as an Ansible inventory file. Inventories are divided into groups and these groups contain the actual hosts. Groups may be populated manually, by entering host names into automation controller, from one of Ansible Automation controller\u2019s supported cloud providers or through dynamic inventory scripts.</p>"},{"location":"automation-platform/automation-platform-intro/#credentials","title":"Credentials","text":"<p>Credentials are utilized by automation controller for authentication when launching Jobs against machines, synchronizing with inventory sources, and importing project content from a version control system. Credential configuration can be found in the Settings.</p> <p>automation controller credentials are imported and stored encrypted in automation controller, and are not retrievable in plain text on the command line by any user. You can grant users and teams the ability to use these credentials, without actually exposing the credential to the user.</p>"},{"location":"automation-platform/automation-platform-intro/#templates","title":"Templates","text":"<p>A job template is a definition and set of parameters for running an Ansible job. Job templates are useful to execute the same job many times. Job templates also encourage the reuse of Ansible playbook content and collaboration between teams. To execute a job, automation Controller requires that you first create a job template.</p>"},{"location":"automation-platform/automation-platform-intro/#jobs","title":"Jobs","text":"<p>A job is basically an instance of automation controller launching an Ansible playbook against an inventory of hosts.</p>"},{"location":"automation-platform/automation-platform-inventory/","title":"2 - Inventory &amp; Ad-hoc commands","text":""},{"location":"automation-platform/automation-platform-inventory/#objective","title":"Objective","text":"<p>Explore and understand the lab environment.  This exercise will cover</p> <ul> <li> <p>Locating and understanding:</p> <ul> <li>Ansible Automation Controller Inventory</li> <li>Ansible Automation Controller Credentials</li> </ul> </li> <li> <p>Running ad hoc commands via the Ansible Automation Controller web UI</p> </li> </ul>"},{"location":"automation-platform/automation-platform-inventory/#guide","title":"Guide","text":""},{"location":"automation-platform/automation-platform-inventory/#examine-an-inventory","title":"Examine an Inventory","text":"<p>The first thing we need is an inventory of your managed hosts. This is the equivalent of an inventory file in Ansible Engine. There is a lot more to it (like dynamic inventories) but let\u2019s start with the basics.</p> <ul> <li>You should already have the web UI open, if not: Point your browser to the URL you were given, similar to <code>https://demo.redhat.com/workshop/pm6xgd</code> (the workshop ID will be different) and log in as <code>admin</code>. The password will be provided by the instructor.</li> </ul> <p>There will be one inventory, the Workshop Inventory. Click the Workshop Inventory then click the Hosts button</p> <p>The inventory information at <code>~/lab_inventory/hosts</code> was pre-loaded into the Ansible Automation controller Inventory as part of the provisioning process.</p> <pre><code>[web]\nnode1 ansible_host=node1.example.com\nnode2 ansible_host=node2.example.com\nnode3 ansible_host=node3.example.com\n\n[control]\nansible-1 ansible_host=ansible-1.example.com\n</code></pre> <p>Warning</p> <p>In your inventory the IP addresses will be different, do not copy the values above!</p>"},{"location":"automation-platform/automation-platform-inventory/#examine-machine-credentials","title":"Examine Machine Credentials","text":"<p>Now we will examine the credentials to access our managed hosts from Automation controller.  As part of the provisioning process for this Ansible Workshop the Workshop Credential has already been setup.</p> <p>In the Resources menu choose Credentials. Now click on the Workshop Credential.</p> <p>Note the following information:</p> Parameter Value Description Credential Type <code>Machine</code> Machine credentials define ssh and user-level privilege escalation access for playbooks. They are used when submitting jobs to run playbooks on a remote host. Username <code>ec2-user</code> The user which matches our command-line Ansible inventory username for the other Linux nodes SSH Private Key <code>Encrypted</code> Note that you can't actually examine the SSH private key once someone hands it over to Ansible Automation controller"},{"location":"automation-platform/automation-platform-inventory/#run-ad-hoc-commands","title":"Run Ad Hoc commands","text":"<p>It is possible to run run ad hoc commands from Ansible Automation controller as well.</p> <p>Tip</p> <p>Ensure that all hosts are available and can be included in automation jobs. Got to Resources \u2192 Hosts and move the slider on the right to On for all hosts.</p> <ul> <li> <p>In the web UI go to Resources \u2192 Inventories \u2192 Workshop Inventory</p> </li> <li> <p>Click the Hosts tab to change into the hosts view and select the three hosts node1 to node3 by ticking the boxes to the left of the host entries.</p> </li> <li> <p>Click Run Command button. In the next screen you have to specify the ad hoc command.</p> </li> </ul> <p>Within the Details window, select Module <code>ping</code> and click Next.</p> <p>Within the Execution Environment window, select Default execution environment and click Next.</p> <p>Within the Machine Credential window, select Workshop Credentials and click Launch.</p> <p>Tip</p> <p>The output of the results is displayed once the command has completed.</p> <p>The simple ping module doesn\u2019t need options. For other modules you need to supply the command to run as an argument. Try the command module to find the userid of the executing user using an ad hoc command.</p> <ul> <li> <p>In the web UI go to Resources \u2192 Inventories \u2192 Workshop Inventory</p> </li> <li> <p>Click the Hosts tab to change into the hosts view and select the three hosts by ticking the boxes to the left of the host entries.</p> </li> <li> <p>Click Run Command button. In the next screen you have to specify the ad hoc command.</p> </li> </ul> <p>Within the Details window, select Module <code>command</code>, in Arguments type <code>id</code> and click Next.</p> <p>Within the Execution Environment window, select Default execution environment and click Next.</p> <p>Within the Machine Credential window, select Workshop Credentials and click Launch.</p> <p>Tip</p> <p>After choosing the module to run, Ansible Automation Controller will provide a link to the docs page for the module when clicking the question mark next to \"Arguments\". This is handy, give it a try.</p> <p>How about trying to get some secret information from the system? Try to print out <code>/etc/shadow</code>.</p> <ul> <li> <p>In the web UI go to Resources \u2192 Inventories \u2192 Workshop Inventory</p> </li> <li> <p>Click the Hosts tab to change into the hosts view and select the three hosts by ticking the boxes to the left of the host entries.</p> </li> <li> <p>Click Run Command button. In the next screen you have to specify the ad hoc command.</p> </li> </ul> <p>Within the Details window, select Module <code>command</code>, in Arguments type <code>cat /etc/shadow</code> and click Next.</p> <p>Within the Execution Environment window, select Default execution environment and click Next.</p> <p>Within the Machine Credential window, select Workshop Credentials and click Launch.</p> <p>Warning</p> <p>Expect an error!</p> <p>Oops, the last one didn\u2019t went well, all red.</p> <p>Re-run the last ad hoc command but this time check the checkbox labeled Enable privilege escalation.</p> <p>As you see, this time it worked. For tasks that have to run as <code>root</code> you need to escalate the privileges. This is the same as the become: yes used in your Ansible Playbooks.</p>"},{"location":"automation-platform/automation-platform-inventory/#challenge-lab-ad-hoc-commands","title":"Challenge Lab: Ad Hoc Commands","text":"<p>Okay, a small challenge: Run an ad hoc to make sure the package \"tmux\" is installed on all hosts. If unsure, consult the documentation either via the web UI as shown above or by running <code>ansible-doc yum</code> on your Automation controller control host.</p> Solution <ul> <li>In the Web UI go to Resources \u2192 Inventories \u2192 Workshop Inventory.  </li> <li>Click the Hosts tab to change into the hosts view and select the three hosts by ticking the boxes to the left of the host entries.</li> <li>Click Run Command button. In the next screen you have to specify the ad hoc command.</li> <li>Within the Details window, select Module <code>yum</code>, in Arguments type <code>name=tmux</code>, check Enable privilege escalation and click Next.</li> <li>Within the Execution Environment window, select Default execution environment and click Next.</li> <li>Within the Machine Credential window, select Workshop Credentials and click Launch.</li> </ul> <p>Info</p> <p>Notice how the package was installed via the \"CHANGED\" output. If you run the ad hoc command a second time, the output will mention \"SUCCESS\" and inform you via the message parameter that there is nothing to do.</p>"},{"location":"automation-platform/automation-platform-inventory/#adjust-aap-settings-for-additional-ad-hoc-module","title":"Adjust AAP settings for additional ad-hoc module","text":"<p>The previous Challenge Lab made use of the <code>yum</code> module, this module only makes sense on older Fedora-based systems like RHEL 7 or RHEL 8 hosts. Previously, we used the generic <code>package</code> module to install packages on the target systems. Let's add this module to the list of modules which can be used with ad-hoc commands.  </p> <ul> <li> <p>In the web UI go to Settings. In the Tab Jobs click on Jobs settings.</p> </li> <li> <p>At the bottom of the page, click the Edit button.</p> </li> <li> <p>In the textarea Ansible Modules Allowed for Ad Hoc Jobs, add <code>\"package\",</code> (in between <code>mount</code> and <code>ping</code> to keep the alphabatical order).</p> </li> </ul> <p>Warning</p> <p>The textarea contains a JSON list! Ensure to use quotation marks and end the line with comma to keep the valid list structure.</p> <ul> <li>After adding the module to the list, scroll down to the bottom of the page and click the Save button.</li> </ul> <p>Now, you are able to use the package module in the ad-hoc command, try to do the previous Challenge Lab by using this module.</p>"},{"location":"automation-platform/automation-platform-projects/","title":"3 - Projects &amp; Job Templates","text":""},{"location":"automation-platform/automation-platform-projects/#objective","title":"Objective","text":"<p>An Ansible automation controller Project is a logical collection of Ansible playbooks. You can manage your playbooks by placing them into a source code management (SCM) system supported by automation controller such as Git or Subversion.</p> <p>This exercise covers:</p> <ul> <li>Understanding and using an Ansible automation controller Project</li> <li>Using Ansible playbooks kept in a Git repository.</li> <li>Creating and using an Ansible Job Template</li> </ul>"},{"location":"automation-platform/automation-platform-projects/#guide","title":"Guide","text":""},{"location":"automation-platform/automation-platform-projects/#setup-git-repository","title":"Setup Git Repository","text":"<p>For this demonstration we will use playbooks stored in a Git repository:</p> <p>https://github.com/ansible/workshop-examples</p> <p>A playbook to install the Apache web server has already been committed to the directory rhel/apache, <code>apache_install.yml</code>:</p> <pre><code>---\n- name: Apache server installed\n  hosts: web\n\n  tasks:\n  - name: latest Apache version installed\n    yum:\n      name: httpd\n      state: latest\n\n  - name: latest firewalld version installed\n    yum:\n      name: firewalld\n      state: latest\n\n  - name: firewalld enabled and running\n    service:\n      name: firewalld\n      enabled: true\n      state: started\n\n  - name: firewalld permits http service\n    firewalld:\n      service: http\n      permanent: true\n      state: enabled\n      immediate: yes\n\n  - name: Apache enabled and running\n    service:\n      name: httpd\n      enabled: true\n      state: started\n</code></pre> <p>Tip</p> <p>Note the difference to other playbooks you might have written! Most importantly there is no <code>become</code> and <code>hosts</code> is set to <code>all</code>.</p> <p>To configure and use this repository as a Source Control Management (SCM) system in automation controller you have to create a Project that uses the repository</p>"},{"location":"automation-platform/automation-platform-projects/#create-the-project","title":"Create the Project","text":"<ul> <li>Go to Resources \u2192 Projects click the Add button. Fill in the form:</li> </ul> Parameter Value Name <code>Workshop Project</code> Organization <code>Default</code> Default Execution Environment <code>Default Execution Environment</code> Source Control Type <code>Git</code> <p>Enter the URL into the Project configuration:</p> Parameter Value Source Control URL <code>https://github.com/ansible/workshop-examples.git</code> Options Select Clean, Delete and Update Revision on Launch to request a fresh copy of the repository and to update the repository when launching a job. <ul> <li>Click SAVE</li> </ul> <p>The new project will be synced automatically after creation. But you can also do this manually: Sync the Project again with the Git repository by going to the Projects view and clicking the circular arrow Sync Project icon to the right of the Project.</p> <p>After starting the sync job, go to the Jobs view: there is a new job for the update of the Git repository.</p>"},{"location":"automation-platform/automation-platform-projects/#create-a-job-template-and-run-a-job","title":"Create a Job Template and Run a Job","text":"<p>A job template is a definition and set of parameters for running an Ansible job. Job templates are useful to execute the same job many times. So before running an Ansible Job from automation controller you must create a Job Template that pulls together:</p> <ul> <li> <p>Inventory: On what hosts should the job run?</p> </li> <li> <p>Credentials What credentials are needed to log into the hosts?</p> </li> <li> <p>Project: Where is the playbook?</p> </li> <li> <p>What playbook to use?</p> </li> </ul> <p>Okay, let\u2019s just do that: Go to the Resources -&gt; Templates view, click the Add button and choose Add job template.</p> <p>Tip</p> <p>Remember that you can often click on magnifying glasses to get an overview of options to pick to fill in fields.</p> Parameter Value Name <code>Install Apache</code> Job Type <code>Run</code> Inventory <code>Workshop Inventory</code> Project <code>Workshop Project</code> Execution Environment <code>Default execution environment</code> Playbook <code>rhel/apache/apache_install.yml</code> Credentials <code>Workshop Credential</code> Limit <code>web</code> Options  Privilege Escalation <ul> <li>Click Save</li> </ul> <p>You can start the job by directly clicking the blue Launch button, or by clicking on the rocket in the Job Templates overview. After launching the Job Template, you are automatically brought to the job overview where you can follow the playbook execution in real time:</p> <p>Job Details </p> <p>Job Run </p> <p>Since this might take some time, have a closer look at all the details provided:</p> <ul> <li> <p>All details of the job template like inventory, project, credentials and playbook are shown.</p> </li> <li> <p>Additionally, the actual revision of the playbook is recorded here - this makes it easier to analyse job runs later on.</p> </li> <li> <p>Also the time of execution with start and end time is recorded, giving you an idea of how long a job execution actually was.</p> </li> <li> <p>Selecting Output shows the output of the running playbook. Click on a node underneath a task and see that detailed information are provided for each task of each node.</p> </li> </ul> <p>After the Job has finished go to the main Jobs view: All jobs are listed here, you should see directly before the Playbook run an Source Control Update was started. This is the Git update we configured for the Project on launch!</p>"},{"location":"automation-platform/automation-platform-projects/#challenge-lab-check-the-result","title":"Challenge Lab: Check the Result","text":"<p>Time for a little challenge:</p> <ul> <li>Use an ad hoc command on all hosts to make sure Apache has been installed and is running.</li> </ul> <p>You have already been through all the steps needed, so try this for yourself.</p> <p>Tip</p> <p>What about <code>systemctl status httpd</code>?</p> Solution <ul> <li>Go to Resources \u2192  Inventories \u2192 Workshop Inventory</li> <li>In the Hosts view select <code>node1</code>, <code>node2</code>, <code>node3</code> and click Run Command</li> <li>Within the Details window, select Module <code>command</code>, in Arguments type <code>systemctl status httpd</code> and click Next.</li> <li>Within the Execution Environment window, select Default execution environment and click Next.</li> <li>Within the Machine Credential window, select Workshop Credential and click Launch.</li> </ul> <p>Info</p> <p>The output of the results is displayed once the command has completed.</p>"},{"location":"automation-platform/automation-platform-rbac/","title":"5 - Role-based access control","text":""},{"location":"automation-platform/automation-platform-rbac/#objective","title":"Objective","text":"<p>You have already learned how Ansible automation controller separates credentials from users. Another advantage of Ansible automation controller is the user and group rights management.  This exercise demonstrates Role Based Access Control (RBAC)</p>"},{"location":"automation-platform/automation-platform-rbac/#guide","title":"Guide","text":""},{"location":"automation-platform/automation-platform-rbac/#ansible-automation-controller-users","title":"Ansible automation controller users","text":"<p>There are three types of automation controller users:</p> <ul> <li> <p>Normal User: Have read and write access limited to the inventory and projects for which that user has been granted the appropriate roles and privileges.</p> </li> <li> <p>System Auditor: Auditors implicitly inherit the read-only capability for all objects within the automation controller environment.</p> </li> <li> <p>System Administrator: Has admin, read, and write privileges over the entire automation controller installation.</p> </li> </ul> <p>Let\u2019s create a user:</p> <ul> <li> <p>In the automation controller menu under Access click Users</p> </li> <li> <p>Click the Add button</p> </li> <li> <p>Fill in the values for the new user:</p> </li> </ul> Parameter Value Username <code>wweb</code> Email <code>wweb@example.com</code> Password <code>ansible</code> Confirm Password <code>ansible</code> First Name <code>Werner</code> Last Name <code>Web</code> Organization <code>Default</code> User Type <code>Normal User</code> <ul> <li>Click Save</li> </ul>"},{"location":"automation-platform/automation-platform-rbac/#ansible-automation-controller-teams","title":"Ansible automation controller teams","text":"<p>A Team is a subdivision of an organization with associated users, projects, credentials, and permissions. Teams provide a means to implement role-based access control schemes and delegate responsibilities across organizations. For instance, permissions may be granted to a whole Team rather than each user on the Team.</p> <p>Create a Team:</p> <ul> <li> <p>In the menu go to Access \u2192 Teams</p> </li> <li> <p>Click the Add button and create a team named <code>Web Content</code> within the <code>Default</code> Organization.</p> </li> <li> <p>Click Save</p> </li> </ul> <p>Add a user to the team:</p> <ul> <li> <p>Click on the team <code>Web Content</code> and click the Access tab and click Add.</p> </li> <li> <p>Within the Select a Resource Type window, click on the Users resource type and click Next.</p> </li> <li> <p>Within the Select Items from List, select the checkbox next to the <code>wweb</code> user and click Next.</p> </li> <li> <p>Within the Select Roles to Apply, select Member as the role to apply to the <code>wweb</code> user.</p> </li> </ul> <p>Click Save.</p> <p>Permissions allow to read, modify, and administer projects, inventories, and other automation controller elements. Permissions can be set for different resources.</p>"},{"location":"automation-platform/automation-platform-rbac/#granting-permissions","title":"Granting permissions","text":"<p>To allow users or teams to actually do something, you have to set permissions. The user wweb should only be allowed to modify content of the assigned webserver.</p> <p>Add the permission to use the <code>Create index.html</code> template:</p> <ul> <li> <p>Within Resources -&gt; Templates, select <code>Create index.html</code>.</p> </li> <li> <p>Select Access tab from the menu and click Add.</p> </li> <li> <p>Within the Select a Resource Type window, click on the Users resource type and click Next.</p> </li> <li> <p>Within the Select Items from List, select the checkbox next to the <code>wweb</code> user and click Next.</p> </li> <li> <p>Within the Select Roles to Apply, select Read and Execute as the roles to apply to the <code>wweb</code> user.</p> </li> <li> <p>Click Save</p> </li> </ul>"},{"location":"automation-platform/automation-platform-rbac/#test-permissions","title":"Test permissions","text":"<p>Now log out of automation controller\u2019s web UI and in again as the wweb user.</p> <ul> <li> <p>Go to the Templates view, you should notice for wweb only the <code>Create   index.html</code> template is listed. He is allowed to view and launch, but not to edit the Template (no Edit button available).</p> </li> <li> <p>Run the Job Template by clicking the rocket icon. Enter the values for the survey questions and launch the job.</p> </li> <li> <p>In the following Jobs view have a good look around, note that there where changes to the host (as expected).</p> </li> </ul> <p>Check the result: execute <code>curl</code> again on the control host to pull the content of the webserver on <code>node1</code> (you could of course check <code>node2</code> and <code>node3</code>, too):</p> <pre><code>[student@ansible-1 ~]$ curl http://node1\n</code></pre> <p>Just recall what you have just done: You enabled a restricted user to run an Ansible playbook</p> <ul> <li> <p>Without having access to the credentials</p> </li> <li> <p>Without being able to change the playbook itself</p> </li> <li> <p>But with the ability to change variables you predefined!</p> </li> </ul> <p>Effectively you provided the power to execute automation to another user without handing out your credentials or giving the user the ability to change the automation code. And yet, at the same time the user can still modify things based on the surveys you created.</p> <p>This capability is one of the main strengths of Ansible automation controller!</p>"},{"location":"automation-platform/automation-platform-surveys/","title":"4 - Surveys","text":""},{"location":"automation-platform/automation-platform-surveys/#objective","title":"Objective","text":"<p>Demonstrate the use of Ansible Automation controller survey feature. Surveys set extra variables for the playbook similar to \u2018Prompt for Extra Variables\u2019 does, but in a user-friendly question and answer way. Surveys also allow for validation of user input.</p>"},{"location":"automation-platform/automation-platform-surveys/#guide","title":"Guide","text":"<p>You have installed Apache on all hosts in the job you just ran. Now we\u2019re going to extend on this:</p> <ul> <li> <p>Use a proper role that has a Jinja2 template to deploy an <code>index.html</code> file.</p> </li> <li> <p>Create a job Template with a survey to collect the values for the <code>index.html</code> template.</p> </li> <li> <p>Launch the job Template</p> </li> </ul> <p>Additionally, the role will make sure that the Apache configuration is properly set up for this exercise.</p> <p>Tip</p> <p>The survey feature only provides a simple query for data - it does not support four-eye principles, queries based on dynamic data or nested menus.</p>"},{"location":"automation-platform/automation-platform-surveys/#the-apache-configuration-role","title":"The Apache-configuration Role","text":"<p>The playbook and the role with the Jinja2 template already exist in the Github repository https://github.com/ansible/workshop-examples in the directory <code>rhel/apache</code>.</p> <p>Head over to the Github UI and have a look at the content: the playbook <code>apache_role_install.yml</code> merely references the role. The role can be found in the <code>roles/role_apache</code> subdirectory.</p> <ul> <li>Inside the role, note the two variables in the <code>templates/index.html.j2</code> template file marked by <code>{{\u2026\u200b}}</code>.</li> <li>Notice the tasks in <code>tasks/main.yml</code> that deploy the file from the template.</li> </ul> <p>What is this playbook doing? It creates a file (dest) on the managed hosts from the template (src).</p> <p>The role deploys a static configuration for Apache. This is to make sure that all changes done in the previous chapters are overwritten and your examples work properly.</p> <p>Because the playbook and role is located in the same Github repo as the <code>apache_install.yml</code> playbook you don't have to configure a new project for this exercise.</p>"},{"location":"automation-platform/automation-platform-surveys/#create-a-template-with-a-survey","title":"Create a Template with a Survey","text":"<p>Now you create a new Template that includes a survey.</p>"},{"location":"automation-platform/automation-platform-surveys/#create-template","title":"Create Template","text":"<ul> <li> <p>Go to Resources \u2192 Templates, click the Add button and choose Add job template</p> </li> <li> <p>Fill out the following information:</p> </li> </ul> Parameter Value Name <code>Create index.html</code> Job Type <code>Run</code> Inventory <code>Workshop Inventory</code> Project <code>Workshop Project</code> Execution Environment <code>Default execution environment</code> Playbook <code>rhel/apache/apache_role_install.yml</code> Credentials <code>Workshop Credential</code> Limit <code>web</code> Options  Privilege Escalation <ul> <li>Click Save</li> </ul> <p>Warning</p> <p>Do not run the template yet!</p>"},{"location":"automation-platform/automation-platform-surveys/#add-the-survey","title":"Add the Survey","text":"<ul> <li> <p>In the Template, click the Survey tab and click the Add button.</p> </li> <li> <p>Fill out the following information:</p> </li> </ul> Parameter Value Question <code>First Line</code> Answer Variable Name <code>first_line</code> Answer Type <code>Text</code> <ul> <li>Click Save</li> <li>Click the Add button</li> </ul> <p>In the same fashion add a second Survey Question</p> Parameter Value Question <code>Second Line</code> Answer Variable Name <code>second_line</code> Answer Type <code>Text</code> <ul> <li>Click Save</li> <li>Click the toggle to turn the Survey questions to On</li> </ul>"},{"location":"automation-platform/automation-platform-surveys/#launch-the-template","title":"Launch the Template","text":"<p>Now launch Create index.html job template by selecting the Details tab and clicking the Launch button.</p> <p>Before the actual launch the survey will ask for First Line and Second Line. Fill in some text and click Next. The Preview window shows the values, if all is good run the Job by clicking Launch.</p> <p>After the job has completed, check the Apache homepage. In the SSH console on the control host, execute <code>curl</code> against <code>node1</code>:</p> <pre><code>[student1@ansible-1 ~]$ curl http://node1\n&lt;body&gt;\n&lt;h1&gt;Apache is running fine&lt;/h1&gt;\n&lt;h1&gt;This is survey field \"First Line\": line one&lt;/h1&gt;\n&lt;h1&gt;This is survey field \"Second Line\": line two&lt;/h1&gt;\n&lt;/body&gt;\n</code></pre> <p>Note how the two variables where used by the playbook to create the content of the <code>index.html</code> file.</p>"},{"location":"automation-platform/automation-platform-workflows/","title":"6 - Workflows","text":""},{"location":"automation-platform/automation-platform-workflows/#objective","title":"Objective","text":"<p>The basic idea of a workflow is to link multiple Job Templates together. They may or may not share inventory, playbooks or even permissions. The links can be conditional:</p> <ul> <li>if job template A succeeds, job template B is automatically executed afterwards</li> <li>but in case of failure, job template C will be run.</li> </ul> <p>And the workflows are not even limited to Job Templates, but can also include project or inventory updates.</p> <p>This enables new applications for Ansible automation controller: different Job Templates can build upon each other. E.g. the networking team creates playbooks with their own content, in their own Git repository and even targeting their own inventory, while the operations team also has their own repos, playbooks and inventory.</p> <p>In this lab you\u2019ll learn how to setup a workflow.</p>"},{"location":"automation-platform/automation-platform-workflows/#guide","title":"Guide","text":""},{"location":"automation-platform/automation-platform-workflows/#lab-scenario","title":"Lab scenario","text":"<p>You have two departments in your organization:</p> <ul> <li>The web operations team that is developing playbooks in their own Git branch named <code>webops</code></li> <li>The web developers team that is developing playbooks in their own Git branch named <code>webdev</code>.</li> </ul> <p>When there is a new Node.js server to deploy, two things need to happen:</p>"},{"location":"automation-platform/automation-platform-workflows/#web-operations-team","title":"Web operations team","text":"<ul> <li><code>httpd</code>, <code>firewalld</code>, and <code>node.js</code> need to be installed, <code>SELinux</code> settings configured, the firewall needs to be opened, and <code>httpd</code> and <code>node.js</code> should get started.</li> </ul>"},{"location":"automation-platform/automation-platform-workflows/#web-developers-team","title":"Web developers team","text":"<ul> <li>The most recent version of the web application needs to be deployed and <code>node.js</code> needs to be restarted.</li> </ul> <p>In other words, the Web operations team prepares a server for application deployment, and the Web developers team deploys the application on the server.</p> <p>To make things somewhat easier for you, everything needed already exists in a Github repository: playbooks, JSP-files etc. You just need to glue it together.</p> <p>Note</p> <p>In this example we use two different branches of the same repository for the content of the separate teams. In reality, the structure of your Source Control repositories depends on a lot of factors and could be different.</p>"},{"location":"automation-platform/automation-platform-workflows/#set-up-projects","title":"Set up projects","text":"<p>First you have to set up the Git repo as a Project like you normally would.</p> <p>Warning</p> <p>If you are still logged in as user wweb, log out of and log in as user admin.</p> <p>Within Resources -&gt; Projects, click the Add button to create a project for the web operations team. Fill out the form as follows:</p> Parameter Value Name <code>Webops Git Repo</code> Organization <code>Default</code> Default Execution Environment <code>Default Execution Environment</code> Source Control Credential Type <code>Git</code> Source Control URL <code>https://github.com/ansible/workshop-examples.git</code> Source Control Branch/Tag/Commit <code>webops</code> Options  Clean Delete Update Revision on Launch <p>Click Save</p> <p>Within Resources -&gt; Projects, click the Add button to create a project for the web developers team. Fill out the form as follows:</p> Parameter Value Name <code>Webdev Git Repo</code> Organization <code>Default</code> Default Execution Environment <code>Default Execution Environment</code> Source Control Credential Type <code>Git</code> Source Control URL <code>https://github.com/ansible/workshop-examples.git</code> Source Control Branch/Tag/Commit <code>webdev</code> Options  Clean Delete Update Revision on Launch <p>Click Save</p>"},{"location":"automation-platform/automation-platform-workflows/#set-up-job-templates","title":"Set up job templates","text":"<p>Now you have to create two Job Templates like you would for \"normal\" Jobs.</p> <p>Within Resources -&gt; Templates, click the Add button and choose Add job template:</p> Parameter Value Name <code>Web App Deploy</code> Job Type <code>Run</code> Inventory <code>Workshop Inventory</code> Project <code>Webops Git Repo</code> Execution Environment <code>Default execution environment</code> Playbook <code>rhel/webops/web_infrastructure.yml</code> Credentials <code>Workshop Credential</code> Limit <code>web</code> Options  Privilege Escalation <p>Click Save</p> <p>Within Resources -&gt; Templates, click the Add button and choose Add job template:</p> Parameter Value Name <code>Node.js Deploy</code> Job Type <code>Run</code> Inventory <code>Workshop Inventory</code> Project <code>Webdev Git Repo</code> Execution Environment <code>Default execution environment</code> Playbook <code>rhel/webdev/install_node_app.yml</code> Credentials <code>Workshop Credential</code> Limit <code>web</code> Options  Privilege Escalation <p>Click Save</p> <p>Tip</p> <p>If you want to know what the Ansible Playbooks look like, check out the Github URL and switch to the appropriate branches.</p>"},{"location":"automation-platform/automation-platform-workflows/#set-up-the-workflow","title":"Set up the workflow","text":"<p>Workflows are configured in the Templates view, you might have noticed you can choose between Add job template and Add workflow template when adding a template.</p> <p>Within Resources -&gt; Templates, click the Add button and choose Add workflow template:</p> Parameter Value Name <code>Deploy Webapp Server</code> Organization <code>Default</code> <p>Click Save</p> <p>After saving the template the Workflow Visualizer opens to allow you to build a workflow. You can later open the Workflow Visualizer again by using the button on the template details page and selecting Visualizer from the menu.</p> <p></p> <p>Click on the Start button, an Add Node window opens. Assign an action to the node, via node     type by selecting Job Template.</p> <p>Select the Web App Deploy job template and click Save.</p> <p></p> <p>A new node is shown, connected to the START button with the name of the job template. Hover the mouse pointer over the node, you\u2019ll see options to add a node (+), view node details (i), edit the node (pencil), link to an available node (chain), and delete the node (trash bin).</p> <p></p> <p>Hover over the node and click the (+) sign to add a new node.</p> <ul> <li>For the Run Type select On Success (default) and click Next.</li> </ul> <p>Tip</p> <p>The run type allows for more complex workflows. You could lay out different execution paths for successful and for failed playbook runs.</p> <ul> <li>For Node Type select Job Template (default) and choose the Node.js Deploy job template. Click Save.</li> </ul> <p></p> <p>Click Save in the top right corner of the Visualizier view.</p> <p>Tip</p> <p>The Visualizer has options for setting up more advanced workflows, please refer to the documentation.</p>"},{"location":"automation-platform/automation-platform-workflows/#launch-workflow","title":"Launch workflow","text":"<p>From within the Deploy Webapp Server Details page, Launch the workflow.</p> <p></p> <p>Note how the workflow run is shown in the Jobs &gt; Deploy Webapp Server Output. In contrast to a normal job template job execution, there is no playbook output when the job completes but the time to complete the job is displayed. If you want to look at the actual playbook run, hover over the node you wish to see the details on and click it. Within the Details view of the job, select the Output menu to see the playbook output. If you want to get back the Output view of the Deploy WebappServer workflow, under Views -&gt; Jobs -&gt; XX - Deploy Webapp Server will take you back to the Output overview.</p> <p>Note</p> <p><code>XX</code> is the number of the job run.</p> <p></p> <p>After the job was finished, check if everything worked fine: from your control host run the following curl command against <code>node1</code>, <code>node2</code> and <code>node3</code>. The output of each curl command should be <code>Hello World</code>.</p> <pre><code>[student@ansible-1 ansible-files]$ curl http://nodeX/nodejs\nHello World\n</code></pre> <p>Note</p> <p><code>X</code> should be replaced with the appropriate number of the node you are checking.</p>"},{"location":"automation-platform/automation-platform-wrapup/","title":"7 - AAP Wrap up","text":""},{"location":"automation-platform/automation-platform-wrapup/#objective","title":"Objective","text":"<p>This is the final challenge where we try to put most of what you have learned together.</p>"},{"location":"automation-platform/automation-platform-wrapup/#guide","title":"Guide","text":""},{"location":"automation-platform/automation-platform-wrapup/#lets-set-the-stage","title":"Let\u2019s set the stage","text":"<p>Your operations team and your application development team likes what they see in Ansible automation controller. To really use it in their environment they put together these requirements:</p> <ul> <li> <p>All webserver hosts (<code>node1</code>, <code>node2</code> and <code>node3</code>) should go in one group</p> </li> <li> <p>As the webserver hosts can be used for development purposes or in production, there has to be a way to flag them accordingly as \"stage dev\" or \"stage prod\".</p> <ul> <li>Currently <code>node1</code> and <code>node3</code> are used as a development system and <code>node2</code> is in production.</li> </ul> </li> <li> <p>Of course the content of the world famous application \"index.html\" will be different between dev and prod stages.</p> <ul> <li>There should be a title on the page stating the environment</li> <li>There should be a content field</li> </ul> </li> <li> <p>The content writer <code>wweb</code> should have access to a survey to change the content for dev and prod servers.</p> </li> </ul>"},{"location":"automation-platform/automation-platform-wrapup/#the-git-repository","title":"The Git Repository","text":"<p>All code is already in place - this is a automation controller lab after all. Check out the Workshop Project git repository at https://github.com/ansible/workshop-examples. There you will find the playbook <code>webcontent.yml</code>, which calls the role <code>role_webcontent</code>.</p> <p>Compared to the previous Apache installation role there is a major difference: there are now multiple versions of an <code>index.html</code> template, and a task deploying the template file, which has a variable as part of the source file name.</p> <p>For the development servers the file is named <code>dev_index.html.j2</code> with the following content:</p> <pre><code>&lt;body&gt;\n&lt;h1&gt;This is a development webserver, have fun!&lt;/h1&gt;\n{{ dev_content }}\n&lt;/body&gt;\n</code></pre> <p>For the production servers the file is named <code>prod_index.html.j2</code> with the following content:</p> <pre><code>&lt;body&gt;\n&lt;h1&gt;This is a production webserver, take care!&lt;/h1&gt;\n{{ prod_content }}\n&lt;/body&gt;\n</code></pre> <p>The playbook <code>main.yml</code> deploys the template:</p> <pre><code>[...]\n- name: Deploy index.html from template\n  template:\n    src: \"{{ stage }}_index.html.j2\"\n    dest: /var/www/html/index.html\n  notify: apache-restart\n</code></pre>"},{"location":"automation-platform/automation-platform-wrapup/#prepare-inventory","title":"Prepare Inventory","text":"<p>There is of course more then one way to accomplish this, but for the purposes of this lab, we will use Ansible automation controller.</p> <p>Within Resources -&gt; Inventories and select 'Workshop Inventory'.</p> <p>Within the Groups tab, click the Add button and create a new inventory group labeled <code>Webserver</code> and click Save.</p> <p>Within the Details tab of the <code>Webserver</code> group, click on Edit. Within the Variables textbox define a variable labeled <code>stage</code> with the value <code>dev</code> and click Save.</p> <pre><code>---\nstage: dev\n</code></pre> <p>Within the Details tab of the <code>Webserver</code> inventory, click the Hosts tab, click the Add button and Add existing host. Select <code>node1</code>, <code>node2</code>, <code>node3</code> as the hosts to be part of the <code>Webserver</code> inventory.</p> <p>Within Resources -&gt; Inventories, select the <code>Workshop</code> Inventory. Click on the <code>Hosts</code> tab and click on <code>node2</code>.  Click on <code>Edit</code> and add the <code>stage: prod</code> variable in the Variables window. This overrides the inventory variable due to order of operations of how the variables are accessed during playbook execution.</p> <p>Within the Variables textbox define a variable labeled <code>stage</code> with the value of <code>prod</code> and click Save.</p> <pre><code>---\nansible_host: &lt;IP_of_node2&gt;\nstage: prod\n</code></pre> <p>Tip</p> <p>Make sure to keep the three dashes that mark the YAML start and the <code>ansible_host</code> line in place!</p>"},{"location":"automation-platform/automation-platform-wrapup/#create-the-template","title":"Create the Template","text":"<p>Within Resources -&gt; Templates, select the Add button and Add job template as follows:</p> Parameter Value Name <code>Create Web Content</code> Job Type <code>Run</code> Inventory <code>Workshop Inventory</code> Project <code>Workshop Project</code> Execution Environment <code>Default execution environment</code> Playbook <code>rhel/apache/webcontent.yml</code> Credentials <code>Workshop Credential</code> Limit <code>web</code> Variables <code>dev_content: \"default dev content\", prod_content: \"default prod content\"</code> Options  Privilege Escalation <p>Click Save.</p> <p>Run the template by clicking the Launch button.</p>"},{"location":"automation-platform/automation-platform-wrapup/#check-the-results","title":"Check the Results","text":"<p>This time we use the power of Ansible to check the results: execute uri to get the web content from each node, orchestrated by an Ansible playbook labeled <code>check_url.yml</code></p> <p>Tip</p> <p>We are using the <code>ansible_host</code> variable in the URL to access every node in the inventory group.</p> <pre><code>---\n- name: Check URL results\n  hosts: web\n  tasks:\n    - name: Check that you can connect (GET) to a page and it returns a status 200\n      ansible.builtin.uri:\n        url: \"http://{{ ansible_host }}\"\n        return_content: true\n      register: uri_output\n\n    - name: Output result\n      ansible.builtin.debug:\n        msg: \"{{ uri_output.content }}\"\n</code></pre> <p>Execute the playbook:</p> <pre><code>[student@ansible-1 ~]$ ansible-playbook check_url.yml\n</code></pre> <p>Snippet of output:</p> <pre><code>TASK [debug] *******************************************************************\nok: [node1] =&gt; {\n    \"uri_output.content\": \"&lt;body&gt;\\n&lt;h1&gt;This is a development webserver, have fun!&lt;/h1&gt;\\ndev wweb&lt;/body&gt;\\n\"\n}\nok: [node2] =&gt; {\n    \"uri_output.content\": \"&lt;body&gt;\\n&lt;h1&gt;This is a production webserver, take care!&lt;/h1&gt;\\nprod wweb&lt;/body&gt;\\n\"\n}\nok: [node3] =&gt; {\n    \"uri_output.content\": \"&lt;body&gt;\\n&lt;h1&gt;This is a development webserver, have fun!&lt;/h1&gt;\\ndev wweb&lt;/body&gt;\\n\"\n}\n</code></pre>"},{"location":"automation-platform/automation-platform-wrapup/#add-survey","title":"Add Survey","text":"<ul> <li>Add a Survey to the template to allow changing the variables <code>dev_content</code> and <code>prod_content</code>.</li> <li>In the Template, click the Survey tab and click the Add button.</li> <li>Fill out the following information:</li> </ul> Parameter Value Question <code>What should the value of dev_content be?</code> Answer Variable Name <code>dev_content</code> Answer Type <code>Text</code> <ul> <li>Click Save</li> <li>Click the Add button</li> </ul> <p>In the same fashion add a second Survey Question</p> Parameter Value Question <code>What should the value of prod_content be?</code> Answer Variable Name <code>prod_content</code> Answer Type <code>Text</code> <ul> <li>Click Save</li> <li> <p>Click the toggle to turn the Survey questions to On</p> </li> <li> <p>Click Preview for the Survey</p> </li> <li> <p>Add permissions to the team <code>Web Content</code> so the template Create Web Content can be executed by <code>wweb</code>.</p> </li> <li> <p>Within the Resources -&gt; Templates, click Create Web Content and add Access to the user <code>wweb</code> the ability to execute the template.</p> <ul> <li>Select a Resource Type -&gt; click Users, click Next.</li> <li>Select Items from List -&gt; select the checkbox <code>wweb</code>, click Next.</li> <li>Select Roles to Apply -&gt; select the checkbox Execute and click Save.</li> </ul> </li> <li> <p>Run the survey as user <code>wweb</code></p> <ul> <li>Logout of the user <code>admin</code> of your Ansible automation controller.</li> <li>Login as <code>wweb</code> and go to Resources -&gt; Templates and run the Create Web Content template.</li> </ul> </li> </ul> <p>Check the results again from your automation controller host. We will use the dedicated <code>uri</code> module within an Ansible playbook. As arguments it needs the actual URL and a flag to output the body in the results.</p> <pre><code>[student@ansible-1 ~]$ ansible-playbook check_url.yml\n</code></pre>"},{"location":"automation-platform/automation-platform-wrapup/#solution","title":"Solution","text":"<p>Warning</p> <p>No solution this time </p> <p>You have done all the required configuration steps in the lab already. If unsure, just refer back to the respective chapters.</p>"},{"location":"demo-environment/editor-alternatives/","title":"Editor Alternatives","text":"<p>It is recommended to use the VS Code Editor for your exercises, if you don't like it, you may use vi or vim in the terminal directly. If you don\u2019t like these as an editor as well, feel free to use Nano or Midnight Commander (mc) in the SSH terminal. Here is a quick introduction to both. And no, I\u2019ll refuse to talk about Emacs\u2026\u200b ;-)</p>"},{"location":"demo-environment/editor-alternatives/#midnight-commander-mc","title":"Midnight Commander (mc)","text":"<p>Mc is more then an editor, it\u2019s a file manager. And it has this nice nineties feel about it\u2026\u200b anyway we\u2019ll focus on editing files here.</p> <p>To open mc at the command-line prompt type:</p> <pre><code># mc\n</code></pre>"},{"location":"demo-environment/editor-alternatives/#basic-editing","title":"Basic Editing","text":"<p>Mc is controlled mainly through the function keys. This can pose all kinds of issues when run in a terminal session, e.g. F10 is most times caught as a shortcut by the terminal window.</p> <p>To work around this:</p> <ul> <li> <p>Try the combination Esc 0 to get F10. Don\u2019t hold Esc!</p> </li> <li> <p>Use the mouse, all mc keys should be clickable, even if they don\u2019t look it.</p> </li> </ul> <p>To create a new file:</p> <ul> <li> <p>Type <code>touch filename</code> in the command field to create an empty file</p> </li> <li> <p>Navigate with the arrow keys in one of the panes to the new file</p> </li> <li> <p>Hit (or click) F4 to start editing the file</p> </li> </ul> <p>To save a file:</p> <ul> <li>Hit (or click) F2 and confirm with Enter</li> </ul> <p>To exit edit mode with or without saving:</p> <ul> <li> <p>Hit Esc 0 or click F10</p> </li> <li> <p>If you did any changes you will be asked \"Save before Close?\".</p> </li> <li> <p>Choose one of the options \"Yes, No, Cancel\" by moving with the arrow or Tab keys (or click)</p> </li> </ul> <p>Copy text internally:</p> <ul> <li> <p>Position the cursor where you want to start to copy</p> </li> <li> <p>Hit (or click) F3 to start selecting</p> </li> <li> <p>Move the cursor to highlight/select the text you want to copy</p> </li> <li> <p>Hit (or click) F3 again to stop selecting</p> </li> </ul> <p>Paste text internally:</p> <ul> <li> <p>Position the cursor where you want to paste the text</p> </li> <li> <p>Hit (or click) F5 to paste a copy of the text</p> </li> <li> <p>Hit (or select) F6 to cut the text and paste it here</p> </li> </ul> <p>Copy text from external source:</p> <ul> <li> <p>mark the text with the mouse, e.g. from the lab guide</p> </li> <li> <p>right-click \u2192 Copy</p> </li> </ul> <p>Paste text from external source:</p> <ul> <li>Click Edit \u2192 Paste in the terminal menu at the top</li> </ul>"},{"location":"demo-environment/editor-alternatives/#short-intro-to-the-nano-editor","title":"Short Intro to the Nano Editor","text":"<p>If you don\u2019t like Vim and you feel too young for Midnight Commander use Nano, a simple to use command line editor.</p>"},{"location":"demo-environment/editor-alternatives/#basic-commands","title":"Basic Commands","text":"<p>Tip</p> <p>Ctrl or Alt means press and hold the Control or Alt key and then press the character after the dash.</p> <p>To create a new file or open an existing file:</p> <pre><code># nano playbook.yml\n</code></pre> <p>Tip</p> <p>When Nano asks for confirmation, it expects a y for yes or n for no.</p> <p>To save the current file in Nano:</p> <ul> <li>Type Ctrl+O</li> </ul> <p>Tip</p> <p>Depending if the file was changed or not Nano will ask for confirmation and the file name.</p> <p>To leave Nano without saving the file (if something went wrong while editing and you just want out without changing anything):</p> <ul> <li>Type Ctrl+X n Enter</li> </ul> <p>Copy and paste external text:</p> <ul> <li> <p>mark the text with the mouse, e.g. from the lab guide</p> </li> <li> <p>right-click \u2192 Copy</p> </li> <li> <p>right-click into the Nano terminal window, then click Paste</p> </li> </ul>"},{"location":"demo-environment/local-demo-environment/","title":"Local Demo Environment","text":"<p>You can also do all exercises in a local development environment, if no Red Hat Demo environment is available. All you need is a Linxu VM or WSL instance with internet access, your development environment must meet the following requirements.</p> <ul> <li>Python 3.9+ (if you want to use the <code>ansible-navigator</code> Python 3.10+ is required!)</li> </ul> <p>The demo environment will mimic the Red Hat Demo Environment with three managed nodes: node1, node2 and node3. The Ansible control node (your VM) will be known as ansible-1 in the lab inventory. Instead of virtual machines, Podman containers are used as the managed nodes.  </p>"},{"location":"demo-environment/local-demo-environment/#lab-diagram","title":"Lab Diagram","text":"<p>The Lab environment consist of an Ansible control node (called <code>ansible-1</code>, your actual VM) and three Managed nodes (called <code>node1</code>, <code>node2</code> and <code>node3</code>, these are all containers). All managed nodes are Rocky8 hosts and are reachable password-less with SSH.</p> <pre><code>stateDiagram-v2\n[*] --&gt; 8002: http\n[*] --&gt; 8005: http\n[*] --&gt; 8008: http\nHost: WSL/VM\nstate Host {\n    8002 --&gt; node1.example.com\n\n    state node1.example.com {\n        webserver1: httpd\n        webserver1_port1: 80\n        webserver1_port1 --&gt; webserver1\n    }\n\n    8005 --&gt; node2.example.com\n\n    state node2.example.com {\n        webserver2: httpd\n        webserver2_port1: 80\n        webserver2_port1 --&gt; webserver2\n    }\n\n    8008 --&gt; node3.example.com\n\n    state node3.example.com {\n        webserver3: httpd\n        webserver3_port1: 80\n        webserver3_port1 --&gt; webserver3\n    }\n}</code></pre> <p>Although containers are used, all managed nodes are accessible via SSH, a couple of ports are exposed with every container:</p> Managed node Port 80 Port 8080 node1 8002 8003 node2 8005 8006 node3 8008 8009 <p>For example, if you want to access a webserver running on port 80 on node2 (this is one of the exercises), you'll need to access it via <code>http://localhost:8005</code> (instead of <code>localhost</code> you may need to use the IP or hostname of your VM).</p> <p>NOTE: If any ports in the range of 8001 to 8009 are already occupied, deployment will fail! You can adjust the ports to be used in the <code>inventory.ini</code></p>"},{"location":"demo-environment/local-demo-environment/#prerequisites","title":"Prerequisites","text":"<p>You'll need Ansible to deploy the Workshop environment, install it with the following command:</p> <pre><code>pip3 install ansible-core==2.16.8\n</code></pre> Why not use the latest version? <p>ansible-core 2.17+ only supports Python 3.7+ for target executions! With many older distributions, the default Python version is Python3.6 or even older (as for RHEL8 or Rocky8 it is <code>/usr/libexec/platform-python</code>, which is Python3.6). With 2.17+, the decision was made to not support such old Python versions anymore (which is understandable as in currently Q3 2024, even Python 3.7 is already EOL), but this obviously has implications on automating older distributions. For now, use the older 2.16.x (or ansible 9 if you installed the complete package), as this is supported/tested until 2025.</p> <p>The playbook for deploying the Workshop environment is hosted in Gihub, you'll need the Git client to clone the project. In most Linux distributions, the Git client is already installed, otherwise install it with the following command, here for a Debian/Ubuntu distribution:</p> <pre><code>sudo apt install git\n</code></pre> <p>To make sure your WSL distribution can start services in the managed node containers, run the following command:</p> <pre><code>sudo apt install dbus-user-session\n</code></pre> Note <p>Without this, you may encounter an error with <code>Failed to connect to bus: No such file or directory</code>.</p> <p>It may be necessary to restart your WSL distribution (open Powershell and run <code>wsl --terminate</code>).</p>"},{"location":"demo-environment/local-demo-environment/#deployment","title":"Deployment","text":"<p>The deployment of the demo environment is automated, we will use Ansible to deploy the Ansible development/learning environment!</p> <p>Clone the project from Github:</p> <pre><code>git clone https://github.com/TimGrt/Workshop-Environment.git\n</code></pre> <p>Change into the directory:</p> <pre><code>cd Workshop-Environment\n</code></pre> <p>Install the necessary requirements for Ansible with the following command:</p> <pre><code>ansible-galaxy collection install -r requirements.yml\n</code></pre> <p>To create the managed node containers, run the <code>create-workshop-environment</code> playbook:</p> <pre><code>ansible-playbook create-workshop-environment.yml\n</code></pre> <p>In short, the playbook will do the following steps:</p> <ol> <li>Install Podman (if necessary).</li> <li>Pull a Docker image and start as many containers as are defined in the inventory.</li> <li>Deploy the Workshop inventory (not the same as is used by this playbook!) to <code>~/lab_inventory/hosts</code>.</li> <li>Add a block with SSH config to access the managed nodes to <code>~/.ssh/config</code>.</li> <li>Deploy the Ansible configuration for the Workshop to <code>~/.ansible.cfg</code>.</li> <li>Create a SSH keypair for the Workshop (<code>~/.ssh/ansible-workshop-environment</code> and <code>~/.ssh/ansible-workshop-environment.pub</code>).</li> <li>Prepare all managed nodes.</li> </ol> <p>For additional information, take a look at the README in the Github project</p>"},{"location":"demo-environment/local-demo-environment/#manual-adjustments","title":"Manual adjustments","text":"<p>As your local <code>/etc/hosts</code> may include multiple personal adjustments the playbook won't change this file!</p> <p>If you want to resolve the hosts (containers) with their hostname, adjust your <code>/etc/hosts</code>:</p> <pre><code>127.0.0.1 localhost node1 node2 node3\n</code></pre> <p>You still need to add the port, but now you can run <code>curl http://node1:8002</code>.</p> <p>The SSH port for every container is also exposed via a high port (node1 on 8001, node2 on 8004 and node3 on 8007), but you can access the managed nodes container like this:</p> <pre><code>ssh node1\n</code></pre> <p>NOTE: First login might take a while, subsequent logins will be faster!</p>"},{"location":"demo-environment/local-demo-environment/#delete-workshop-environment","title":"Delete Workshop environment","text":"<p>After completing the workshop, you can remove all traces of the demo environment by running the <code>delete-workshop-environment</code> playbook:</p> <pre><code>ansible-playbook delete-workshop-environment.yml\n</code></pre> <p>The playbook will do the following steps:</p> <ol> <li>Delete the managed node containers.</li> <li>Delete the folder with the workshop inventory (<code>~/lab_inventory/hosts</code>).</li> <li>Remove the managed nodes from <code>~/.ssh/known_hosts</code> if they were accessed manually.</li> <li>Delete the block from <code>~/.ssh/config</code> which was added for the workshop.</li> <li>Delete the Ansible configuration from <code>~/.ansible.cfg</code>, if a backup was created, a hint is shown.</li> <li>Delete the keypair created for the workshop (<code>~/.ssh/ansible-workshop-environment</code> and <code>~/.ssh/ansible-workshop-environment.pub</code>).</li> </ol> <p>If you want to delete the Podman installation as well, run the playbook like this:</p> <pre><code>ansible-playbook delete-workshop-environment.yml -e delete_podman=true\n</code></pre>"},{"location":"demo-environment/red-hat-demo-environment/","title":"RedHat Demo Environment","text":"<p>Every Workshop attendant has his own demo environment.</p>"},{"location":"demo-environment/red-hat-demo-environment/#lab-diagram","title":"Lab Diagram","text":"<p>The Lab environment consist of an Ansible control node (called <code>ansible-1</code>) and three Managed nodes (called <code>node1</code>, <code>node2</code> and <code>node3</code>). All managed nodes are RHEL 8 hosts and are reachable password-less with SSH.</p> <p></p> <p>You will be logged in to the Ansible Control node with the Code editor Visual Studio Code. From here you will be writing all your playbooks and issuing all Ansible CLI commands.</p>"},{"location":"demo-environment/red-hat-demo-environment/#visual-studio-code","title":"Visual Studio Code","text":"<p>At its heart, Visual Studio Code is a code editor. Like many other code editors, VS Code adopts a common user interface and layout of an explorer on the left, showing all of the files and folders you have access to, and an editor on the right, showing the content of the files you have opened.</p> <p>Tip</p> <p>It is highly recommended to use the VS Code Editor to write your playbooks, it has automatic saving and syntax highlighting enabled!</p> <p>If you want the real YAML challenge, try to write all your playbooks in the terminal/on the command-line. Expect to struggle at first with indentation, which leads to errors trying to run your playbooks. Nevertheless, mastering to write Ansible playbooks without the help of a Code editor is the best possible way to really understand the YAML syntax. It doesn't take long and is highly rewarding.</p>"},{"location":"demo-environment/red-hat-demo-environment/#useful-vscode-configuration","title":"Useful VScode configuration","text":""},{"location":"demo-environment/red-hat-demo-environment/#color-theme-for-syntax-highlighting","title":"Color theme for syntax highlighting","text":"<p>The Ansible extension supports syntax-highlighting for Ansible content. Depending on the used theme of VScode, this might not be shown correctly. Use the Default Dark+ theme. Click on File in the top menu bar, click on Preferences and open Settings. Search for <code>theme</code> and choose the Dark+ (default dark) from the drop-down menu.</p> <p></p>"},{"location":"demo-environment/red-hat-demo-environment/#terminal-scrollback","title":"Terminal Scrollback","text":"<p>By default, scrollback of only 1000 lines is possible. If you need to scroll back further, you need to adjust this limit. Click on File in the top menu bar, click on Preferences and open Settings. Search for <code>scrollback</code> and adjust the number to 10000 in the second configuration parameter (Terminal &gt; Integrated: Scrollback).</p> <p></p>"},{"location":"projects/projects-overview/","title":"Overview","text":"<p>This section includes a couple of small projects which will further enhance your Ansible automation skills. Depending on the length or the focus of the workshop, you will do one or more of these projects.</p> <ul> <li>Linux Automation - Grafana Deployment</li> <li>Network Automation - CISCO ACI Automation</li> <li>Cloud Automation - AWS</li> <li>DCIM Automation - Netbox</li> </ul> <p>All of the projects are done in or with the Lab environment.</p>"},{"location":"projects/cloud-automation/aws-project/","title":"Project - AWS Automation","text":"<p>Automating Cloud infrastructure is getting more and more important. Tools like Terraform are well suited for provisioning infrastructure in public cloud environments. When dealing with immutable infrastructure, Terraform works well and is great at provisioning cloud resources and applications for AWS, Azure, Docker, GCP, and others.  However, there is more to IT operations than automated infrastructure provisioning and this is why Ansible is extremely popular as well.</p> <p>Terraform is an excellent cloud provisioning and de-provisioning tool for infrastructure as code.  Ansible is a great all-purpose, cross-domain automation solution. Together, they perform in harmony to create a better experience for developers and operations teams. Still, this workshops focus is Ansible, let us do provisioning and configuration in the cloud with the tool we learned.</p>"},{"location":"projects/cloud-automation/aws-project/#objective","title":"Objective","text":"<p>Get to know cloud automation with Ansible. Cloud automation uses the basic Ansible concepts, but there are some differences in how the modules work. From a user\u2019s point of view, cloud modules work like any other modules. They work with ad hoc commands, playbooks, and roles. Behind the scenes, however, cloud modules use a different methodology than the other (Linux/Unix and Windows) modules use. As we are communicating with an API endpoint, but Ansible and most of its modules are written and executed in Python, you need to use the Python interpreter on the Ansible control node.</p>"},{"location":"projects/cloud-automation/aws-project/#requirements","title":"Requirements","text":"<p>For doing the following exercises, you will need an AWS Account and an AWS Access key (consists of an Access Key ID and a Secret Access Key).  After creating your AWS Account, go to the navigation bar on the upper right, choose your user name, and then choose Security credentials. In the Access keys section, choose Create access key.  On the Access key best practices &amp; alternatives page, choose your use case to learn about additional options which can help you avoid creating a long-term access key. Mark the checkbox and click Create Access Key. On the Retrieve access keys page, choose either Show to reveal the value of your user's secret access key, or Download .csv file. This is your only opportunity to save your secret access key. After you've saved your secret access key in a secure location, choose Done.</p> <p>Tip</p> <p>Most modules need the region set, use the region <code>eu-central-1</code> throughout your playbook.</p>"},{"location":"projects/cloud-automation/aws-project/#guide","title":"Guide","text":"<p>The following steps explain and train you how to use the modules and inventory scripts to automate your AWS resources with Ansible.</p>"},{"location":"projects/cloud-automation/aws-project/#step-1-prepare-controller","title":"Step 1 - Prepare controller","text":"<p>Today, you will need additional Ansible modules. In the first part of the workshop, we only used a handful of modules which are all included in the <code>ansible-core</code> binary. With ansible-core only 69 of the most used modules are included:</p> <pre><code>[student@ansible-1 ~]$ ansible-doc -l\nadd_host               Add a host (and alternatively a group) to the ansible-playbook in-memory inventory  \napt                    Manages apt-packages  \napt_key                Add or remove an apt key  \napt_repository         Add and remove APT repositories  \nassemble               Assemble configuration files from fragments  \nassert                 Asserts given expressions are true  \nasync_status           Obtain status of asynchronous task  \nblockinfile            Insert/update/remove a text block surrounded by marker lines  \ncommand                Execute commands on targets  \ncopy                   Copy files to remote locations\n...\n</code></pre> <p>Additional modules are installed through collections, search the Collection Index in the Ansible documentation for a suitable collection or use the search field.</p> <p></p> <p>Once you found the appropriate collection, install it with the <code>ansible-galaxy</code> CLI command:</p> <pre><code>ansible-galaxy collection install provider.collection\n</code></pre> <p>Requirements for the AWS modules are minimal, you will need an additional Python package. Install the package with this command:</p> <pre><code>pip3.9 install boto3 --user\n</code></pre> <p>Note</p> <p>Note the version of the Python package manager utility (<code>pip3.9</code>)! Your Ansible control node might have multiple Python versions installed, install necessary dependencies for the Python version that Ansible uses. You can check for the Python interpreter of Ansible with the <code>ansible --version</code> command:</p> <p><pre><code>[student@ansible-1 ~]$ ansible --version\nansible [core 2.14.0]\nconfig file = /etc/ansible/ansible.cfg\nconfigured module search path = ['/home/student/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']\nansible python module location = /usr/lib/python3.9/site-packages/ansible\nansible collection location = /home/student/.ansible/collections:/usr/share/ansible/collections\nexecutable location = /usr/bin/ansible*\npython version = 3.9.13 (main, Nov  9 2022, 13:16:24) [GCC 8.5.0 20210514 (Red Hat 8.5.0-15)] (/usr/bin/python3.9)\njinja version = 3.1.2\nlibyaml = True\n</code></pre> Do not use sudo when installing Python packages. If you get a Permission denied, add <code>--user</code>, this installs the dependencies to <code>~/.local/lib</code>.</p> <p>Achieve the following tasks:</p> <ul> <li> Find appropriate collection for AWS automation in the documentation</li> <li> Collection installed</li> <li> Python requirements installed</li> </ul> <p>You can view the installed collections with this command:</p> <pre><code>[student@ansible-1 aci-automation]$ ansible-galaxy collection list\n# /home/student/.ansible/collections/ansible_collections\nCollection        Version\n----------------- -------\nansible.posix     1.4.0  \ncommunity.docker  2.7.0  \ncommunity.general 5.3.0\n</code></pre>"},{"location":"projects/cloud-automation/aws-project/#step-2-prepare-project","title":"Step 2 - Prepare project","text":"<p>Create a new project folder in your home directory:</p> <pre><code>[student@ansible-1 ~]$ mkdir aws-automation\n</code></pre> <p>Within your newly created project folder, create a playbook file.</p> <p>Tip</p> <p>You have to instruct Ansible to communicate with the AWS API, per default Ansible would try to communicate via SSH. This will not work. Set the target of your playbook to your local machine.  </p> <p>The documentation provides an extensive Guide for AWS automation which can help you setting up everything. For successful communication with the AWS API, you need to authenticate yourself, this is where your previously created Access key is needed.  </p> <p>You can either specify your credentials as module arguments (you'll need to repeat them with every module) or as environment variables. The first variant would require you to set the credentials in variables (which need to be encrypted, this can be achieved with ansible-vault). Let's use the method with environment variables, this eases the first steps and is also applicable if you would run your playbook in the Ansible Automation Platform.</p> <p>Set the environment variables on the CLI:</p> <pre><code>export AWS_ACCESS_KEY_ID='AK123'\nexport AWS_SECRET_ACCESS_KEY='abc123'\n</code></pre> <p>Warning</p> <p>Environment variables are only set in the current session, if you close your terminal, you'll need to set them again.</p> <p>To remember setting the variables, you could include this optional task as the first in your playbook which asserts that the variables are set. If the variables are missing, it will fail the playbook with a hint on what to do:</p> <pre><code>- name: Ensure AWS credentials are set\n  ansible.builtin.assert:\n  that:\n    - ansible_env.AWS_ACCESS_KEY_ID is defined\n    - ansible_env.AWS_SECRET_ACCESS_KEY is defined\n  quiet: true\n  fail_msg: |\n    No environment variables with AWS credentials found!\n    Set the variables with:\n      export AWS_ACCESS_KEY_ID='AK123'\n      export AWS_SECRET_ACCESS_KEY='abc123'\n</code></pre> <p>Danger</p> <p>Your bash history reveals the CLI input and your credentials! You can delete the respective entry with <code>history -d &lt;position&gt;</code>.</p> Alternative solution <p>You can set your credentials in a hidden file <code>~/.aws/credentials</code> in your home directory in an ini file:</p> <pre><code>[workshop]\naws_access_key_id = YOUR_AWS_ACCESS_KEY_ID\naws_secret_access_key = YOUR_AWS_SECRET_ACCESS_KEY\n</code></pre> <p>The section represents a credential profile which needs to be added to every module with the key-value-pair <code>aws_profile: profile_name</code>, in our example with <code>aws_profile: workshop</code>.</p> <p>Note, this solution also does not store the credentials in an encrypted way! Everybody with access to your home directory would be able to read your credentials! In production, its best to use an external credential provider. In the Ansible Automation platform you can store your variables in an encrypted database or use multiple credential provider plugins.</p> <p>Testing the successful communication with the API could be done by querying information about an EC2 AMI Image. Find an appropriate module, create your playbook and add a task. Try to gather information about the following AMI, you can copy the content with a button:</p> <pre><code>ami-06c39ed6b42908a36\n</code></pre> <p>The AMI is available in the eu-central-1 region, you may to define this in the module you've chosen.  </p> <p>Run your playbook, if it returns a green ok status, communication is established. For now, the gathered information about the AMI is not relevant for us, still, you could store the output in a variable and output it with an appropriate module, if you are curious.</p> <p>Achieve the following tasks:</p> <ul> <li> Playbook created</li> <li> Successful communication with AWS established</li> </ul>"},{"location":"projects/cloud-automation/aws-project/#step-3-create-ssh-key-pair","title":"Step 3 - Create SSH key-pair","text":"<p>In a later step, we will create EC2 instances. To be able to login to these hosts, we need a SSH key-pair. Let's create a dedicated key, this can be achieved with the module <code>openssh_keypair</code>. The module is not part of the ansible.builtin collection, try to find the collection where the module is stored (Tip: Use the search field in the documentation). When you found the correct collection, install it with the <code>ansible-galaxy collection install</code> command.</p> <p>Add a task to your playbook which creates a key-pair in the default folder in your home directory (<code>~/.ssh</code>). The key should be called <code>workshop</code>, the module will create a private key with this name and a public key with the name <code>workshop.pub</code>. The home directory of the user running the playbook is stored in the fact <code>ansible_env.HOME</code>, use this as a variable and append <code>/.ssh/workshop</code>.  </p> <p>Success</p> <p>Use a key size of 2048 bits!</p> <p>Now, lets create the EC2 key-pair named <code>workshop</code> in AWS with our playbook. Find the correct module and provide the public key created by the previous task. You can access the content of the public key with a lookup plugin:</p> <pre><code>\"{{ lookup('file', ansible_env.HOME + '/.ssh/workshop.pub') }}\"\n</code></pre> <p>Achieve the following tasks:</p> <ul> <li> Collection with module <code>openssh_keypair</code> found and installed</li> <li> Added task to create key pair with 2048 bits</li> <li> Added task to create new AWS EC2 keypair using public key of previously created local keypair</li> </ul>"},{"location":"projects/cloud-automation/aws-project/#step-4-get-default-vpc","title":"Step 4 - Get default VPC","text":"<p>A AWS Virtual Private Cloud should already be configured for you, lets use this for our workshop. We need to get the ID of the default VPC net, this can be achieved with Ansible as well. Find the correct module to gather information about EC2 VPCs and add it to your playbook. Add the following parameters:</p> <pre><code>region: eu-central-1\nfilters:\n  \"is-default\": true\n</code></pre> <p>Store the output of the module in a variable, e.g. <code>vpc_info</code>. Afterwards, add the following task which sets a fact/variable with the ID of your default VPC:</p> <pre><code>- name: Set variable with ID of default VPC\n  set_fact:\n    default_vpc_id: \"{{ vpc_info.vpcs.0.vpc_id }}\"\n</code></pre> <p>The variable <code>vpc_info</code> contains a list <code>vpcs</code>. As we filtered for the default VPC, the list only contains one element, therefore we can access the list item with <code>0</code>. The list item contains a key <code>vpc_id</code>, the value is what we are looking for.</p> <p>Achieve the following tasks:</p> <ul> <li> Module for gathering VPC info identified and used</li> <li> set_fact Task returns green \"ok\" status</li> </ul> <p>If you are curious, add another task which debugs the variable to stdout.</p>"},{"location":"projects/cloud-automation/aws-project/#step-5-create-security-group","title":"Step 5 - Create Security group","text":"<p>We need to create a security group and add a rule for incoming SSH access to be able to login to our EC2 instance later. Find the correct module and add a task, provide the following parameter:</p> Parameter Value Description name workshop-sg The name of the Security group description Security group created by Ansible Short description vpc_id \"{{ default_vpc_id }}\" The value of your variable <code>default_vpc_id</code> region eu-central-1 The region we used in all other tasks <p>The <code>rules</code> parameter must hold a list, in our case a single rule is enough. Find the correct rule parameters and use the following values:</p> <ul> <li>Protocol: TCP</li> <li>From: 22</li> <li>To: 22</li> <li>CIDR: 0.0.0.0/0</li> </ul> <p>Run your playbook.</p> <p>Achieve the following tasks:</p> <ul> <li> Module for maintaining security groups identified and used</li> <li> Security group successfully created</li> </ul>"},{"location":"projects/cloud-automation/aws-project/#step-6-create-ec2-instance","title":"Step 6 - Create EC2 instance","text":"<p>Now it's finally time to create a virtual machine in AWS. Find the appropriate module and add a task to your playbook, your instance should have the following configuration (this time it is up to you to find the correct key-value-pairs):</p> <ul> <li>Must be called <code>workshop-instance1</code></li> <li>Must be created in <code>eu-central-1</code></li> <li>Must have a public IP address</li> <li>Must have the <code>workshop</code> key assigned</li> <li>Must have the size <code>t2.micro</code></li> <li>Must be in the security group <code>workshop-sg</code></li> <li>Must use the AMI <code>ami-06c39ed6b42908a36</code></li> <li>Should have the tag <code>Environment: Testing</code> attached</li> </ul> <p>Choose the right value for the <code>state</code> parameter, your playbook should wait for a running instance!</p> <p>Achieve the following task:</p> <ul> <li> Running EC2 instance</li> </ul>"},{"location":"projects/cloud-automation/aws-project/#step-7-get-dns-name-and-login","title":"Step 7 - Get DNS name and login","text":"<p>Find a module to gather information about your EC2 instances in your region, use the filter <code>\"tag:Name\": workshop-instance1</code> to only get this single instance. Store the output of the module into a variable and use the variable in another task which debugs only the public DNS name of your previously created EC2 instance.</p> <pre><code>TASK [Output public DNS name of workshop-instance1] ****************************************************************************************************************\nok: [localhost] =&gt;\n  msg: ec2-3-70-238-39.eu-central-1.compute.amazonaws.com\n</code></pre> <p>Copy the output of your task and login to your EC2 instance with SSH. Provide the private key and use the user <code>ec2-user</code>, for example:</p> <pre><code>[student@ansible-1 ~]$ ssh -i ~/.ssh/workshop ec2-user@ec2-3-70-238-39.eu-central-1.compute.amazonaws.com\nLast login: Sat Feb 11 13:27:56 2023 from ec2-3-71-15-149.eu-central-1.compute.amazonaws.com\n\n       __|  __|_  )\n       _|  (     /   Amazon Linux 2 AMI\n      ___|\\___|___|\n\nhttps://aws.amazon.com/amazon-linux-2/\n16 package(s) needed for security, out of 16 available\nRun \"sudo yum update\" to apply all updates.\n</code></pre> <p>Achieve the following tasks:</p> <ul> <li> Added task to gather information about EC2 instances</li> <li> Added task to output public DNS name of instance</li> <li> Successful SSH login to EC2 instance</li> </ul> <p>Success</p> <p>Awesome, you created a virtual machine in the Cloud and are able to login!</p>"},{"location":"projects/cloud-automation/aws-project/#optional","title":"Optional","text":""},{"location":"projects/cloud-automation/aws-project/#step-1-create-multiple-ec2-instances","title":"Step 1 - Create multiple EC2 instances","text":"<p>In Step 5 you created a single EC2 instance, adjust your task to create multiple instances in a loop. The name of every instance must differ, as well as the <code>Environment</code> tag. Create three instances with the single task, with the instance being in the given Environment :</p> Name Environment (Tag) workshop-instance1 Testing workshop-instance2 Testing workshop-instance3 Production <p>Run your playbook, you should see two more instances being created.</p> <p>Achieve the following task:</p> <ul> <li> Adjusted task to create three EC2 instances <code>workshop-instance[1-3]</code></li> </ul>"},{"location":"projects/cloud-automation/aws-project/#step-2-create-dynamic-inventory","title":"Step 2 - Create dynamic inventory","text":"<p>When using Ansible with AWS, inventory file maintenance will be a hectic task as AWS frequently changes IPs, autoscaling instances, and more. Once your AWS EC2 hosts are spun up, you\u2019ll probably want to talk to them again. With a cloud setup, it\u2019s best not to maintain a static list of cloud hostnames in text files. Rather, the best way to handle this is to use the <code>aws_ec2</code> dynamic inventory plugin.  </p> <p>Create a file <code>workshop.aws_ec2.yml</code></p> <p>The inventory should have two additional groups <code>test_stage</code> and <code>prod_stage</code>. The hosts have a tag <code>Environment</code> with either <code>Testing</code> or <code>Production</code>, ensure that they are part of the correct group. You can test your inventory with the <code>ansible-inventory</code> CLI utility, it outputs a JSON representation of how Ansible sees your provided inventory.</p> <pre><code>[student@ansible-1 aws-automation]$ ansible-inventory -i demo.aws_ec2.yml --list\n{\n    \"_meta\": {\n        [..Cut for better readability..]\n    }\n    \"all\": {\n        \"children\": [\n            \"aws_ec2\",\n            \"prod_stage\",\n            \"test_stage\",\n            \"ungrouped\"\n        ]\n    },\n    \"aws_ec2\": {\n        \"hosts\": [\n            \"ec2-18-185-94-35.eu-central-1.compute.amazonaws.com\",\n            \"ec2-3-126-92-75.eu-central-1.compute.amazonaws.com\",\n            \"ec2-3-70-238-39.eu-central-1.compute.amazonaws.com\"\n        ]\n    },\n    \"prod_stage\": {\n        \"hosts\": [\n            \"ec2-18-185-94-35.eu-central-1.compute.amazonaws.com\"\n        ]\n    },\n    \"test_stage\": {\n        \"hosts\": [\n            \"ec2-3-126-92-75.eu-central-1.compute.amazonaws.com\",\n            \"ec2-3-70-238-39.eu-central-1.compute.amazonaws.com\"\n        ]\n    }\n}\n</code></pre> <p>You need to set some Ansible connection variables, remember, direct SSH connection also only worked when providing the SSH private key and the target user.</p> <p>Tip</p> <p>The documentation has a typo, the variable for the SSH private key file is not <code>ansible_private_ssh_key_file</code> but <code>ansible_ssh_private_key_file</code>!</p> <p>When you finished your inventory, use this playbook to test the connection:</p> test-connection.yml<pre><code>---\n- name: Playbook targeting hosts from dynamic inventory\n  hosts: test_stage\n  tasks:\n    - name: Try to reach hosts\n      ansible.builtin.ping:\n</code></pre> <p>Running the playbook (and providing the inventory!) results in the following output:</p> <pre><code>[student@ansible-1 aws-automation]$ ansible-playbook -i workshop.aws_ec2.yml test.yml\n\nPLAY [Playbook targeting hosts from dynamic inventory] ***************************************************************************************************************\n\nTASK [Gathering Facts] ***********************************************************************************************************************************************\nok: [ec2-3-70-238-39.eu-central-1.compute.amazonaws.com]\nok: [ec2-3-126-92-75.eu-central-1.compute.amazonaws.com]\n\nTASK [Try to reach hosts] ********************************************************************************************************************************************\nok: [ec2-3-126-92-75.eu-central-1.compute.amazonaws.com]\nok: [ec2-3-70-238-39.eu-central-1.compute.amazonaws.com]\n\nPLAY RECAP ***********************************************************************************************************************************************************\nec2-3-126-92-75.eu-central-1.compute.amazonaws.com : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0  \nec2-3-70-238-39.eu-central-1.compute.amazonaws.com : ok=2    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0  \n</code></pre> Help wanted? <p>Authentication is done here with the credentials stored in <code>~/.aws/credentials</code></p> <pre><code># demo.aws_ec2.yml\nplugin: amazon.aws.aws_ec2\n\naws_profile: workshop\n\nregions:\n  - eu-central-1\n\ngroups:\n  test_stage: \"'Testing' in tags.Environment\"\n  prod_stage: \"'Production' in tags.Environment\"\n\nfilters:\n  instance-state-name: running\n\ncompose:\n  ansible_host: public_dns_name\n  ansible_ssh_private_key_file: ~/.ssh/workshop\n  ansible_user: ec2-user\n</code></pre>"},{"location":"projects/cloud-automation/aws-project/#cleanup","title":"Cleanup","text":"<p>Warning</p> <p>When you are done, remember to clean up all created resources in AWS to prevent incurring costs!</p> <p>You created the following resources in AWS:</p> <ul> <li>EC2 Instance(s)</li> <li>Security Group</li> <li>SSH Keypair</li> </ul>"},{"location":"projects/dcim-ipam-automation/netbox-project/","title":"Project - DCIM Automation","text":"<p>Datacenter Inventory Management and IP Address Management are indispensable in today's large data centers. NetBox offers both functions including a versatile API.</p> <p> </p> <p>NetBox has curated a data model which caters specifically to the needs of network engineers and operators. It delivers a wide assortment of object types to best serve the needs of infrastructure design and documentation. These cover all facets of network technology, from IP address managements to cabling to overlays and more.</p> <p> </p>"},{"location":"projects/dcim-ipam-automation/netbox-project/#objective","title":"Objective","text":"<p>Create an Ansible project from scratch, automate against an API and make use of an Ansible dynamic inventory.</p>"},{"location":"projects/dcim-ipam-automation/netbox-project/#guide","title":"Guide","text":""},{"location":"projects/dcim-ipam-automation/netbox-project/#step-1-prepare-project","title":"Step 1 - Prepare project","text":"<p>Create a new project folder in your home directory:</p> <pre><code>[student@ansible-1 ~]$ mkdir netbox-automation\n</code></pre> <p>We will be using a Netbox Demo available online.</p> <p>Open a new browser tab and go to https://demo.netbox.dev/.</p> <p>Tip</p> <p>You can create personal login credentials yourself. Once logged in, you can create an API token which you will need for your automation tasks. Either use the link or click on your username in the upper right corner of the Netbox UI and select API Tokens from the dropdown menu.</p> <p>Today, you'll need additional Ansible modules. In the first part of the workshop, we only used a handful of modules which are all included in the <code>ansible-core</code> binary. With ansible-core only 69 of the most used modules are included:</p> <pre><code>[student@ansible-1 ~]$ ansible-doc -l\nadd_host               Add a host (and alternatively a group) to the ansible-playbook in-memory inventory  \napt                    Manages apt-packages  \napt_key                Add or remove an apt key  \napt_repository         Add and remove APT repositories  \nassemble               Assemble configuration files from fragments  \nassert                 Asserts given expressions are true  \nasync_status           Obtain status of asynchronous task  \nblockinfile            Insert/update/remove a text block surrounded by marker lines  \ncommand                Execute commands on targets  \ncopy                   Copy files to remote locations\n...\n</code></pre> <p>Additional modules are installed through collections, search the Collection Index in the Ansible documentation for a module or use the search field.</p> <p></p> <p>If, for example, you want to create an EC2 instance in AWS, you will need the module <code>amazon.aws.ec2_instance</code>. To get the module, you'll need the collection <code>aws</code> of the provider <code>amazon</code>. Download the collection with the <code>ansible-galaxy</code> utility:</p> <pre><code>[student@ansible-1 ~]$ ansible-galaxy collection install amazon.aws\nStarting galaxy collection install process\nProcess install dependency map\nStarting collection install process\nDownloading https://galaxy.ansible.com/download/amazon-aws-3.2.0.tar.gz to /home/student/.ansible/tmp/ansible-local-55382m3kkt4we/tmp7b2kxag4/amazon-aws-3.2.0-3itpmahr\nInstalling 'amazon.aws:3.2.0' to '/home/student/.ansible/collections/ansible_collections/amazon/aws'\namazon.aws:3.2.0 was installed successfully\n</code></pre> <p>Tip</p> <p>Well, you won't need the AWS collection, but automating the Netbox with Ansible also requires additional modules, these are not included in the <code>ansible-core</code> binary and need to be installed with Ansible Galaxy.</p> <p>Achieve the following tasks:</p> <ul> <li> Find appropriate collection for Netbox automation in the documentation</li> <li> Collection installed</li> </ul> <p>You can view the installed collections with this command:</p> <pre><code>[student@ansible-1 netbox-automation]$ ansible-galaxy collection list\n# /home/student/.ansible/collections/ansible_collections\nCollection        Version\n----------------- -------\nansible.posix     1.4.0  \ncommunity.docker  2.7.0  \ncommunity.general 5.3.0\n</code></pre>"},{"location":"projects/dcim-ipam-automation/netbox-project/#step-2-inventory-and-playbook","title":"Step 2 - Inventory and playbook","text":"<p>Within your newly created project folder, create an inventory file and a playbook file.</p> <p>Tip</p> <p>You have to instruct Ansible to communicate with the Netbox API, by default Ansible would try to communicate via SSH. This will not work. Use the API token you created in the Netbox UI.</p> <p>Testing the successful communication with the API could be done by querying all available tenants with the <code>nb_lookup</code> plugin. Take a look at the documentation for how to use it, use the search to find it. Create your playbook and add a task with the debug module, utilizing the lookup plugin. In the documented example the loop uses the query function, instead of <code>devices</code> search for <code>tenant</code>, the variable to output can be <code>{{ item.value.display }}</code> for the name of the respective tenant. Run your playbook, if it returns a green ok status, communication is established.</p> Help wanted? <p>Use the following task to get a list of all already configured tenants.</p> <pre><code>- name: Obtain list of tenants from NetBox\n  debug:\n    msg: \"{{ item.value.display }}\"\n  loop: \"{{ query('netbox.netbox.nb_lookup', 'tenants', api_endpoint=https://demo.netbox.dev/, token=YOUR_NETBOX_TOKEN) }}\"\n  loop_control:\n    label: \"ID: {{ item.key }}\"\n</code></pre> <p>The loop_control is not really necessary, but improves readability.</p> <p>Tip</p> <p>You need to input your personal API token.</p> <p>Achieve the following tasks:</p> <ul> <li> Inventory and playbook created</li> <li> Use variables where possible (and useful)</li> <li> Successful communication with API established</li> </ul>"},{"location":"projects/dcim-ipam-automation/netbox-project/#step-3-create-a-new-tenant","title":"Step 3 - Create a new Tenant","text":"<p>Most core objects within NetBox's data model support tenancy. This is the association of an object with a particular tenant to convey ownership or dependency.</p> <p>The goal is to create a new Netbox tenant with Ansible. The tenant should have the following properties, which can be set with the parameters of the appropriate module:</p> Parameter Value name <code>Demo Tenant &lt;Initials&gt;</code> slug <code>demo_tenant_&lt;initials&gt;</code> description <code>Workshop tenant</code> tenant_group <code>cc_workshop</code> <p>Warning</p> <p>Replace <code>&lt;Initials&gt;</code> with your personal initials to identify the objects later on.</p> <p>Achieve the following tasks:</p> <ul> <li> Tenant created</li> <li> Tenant is part of <code>cc_workshop</code> tenant group</li> <li> Inspect tenant in the UI</li> </ul>"},{"location":"projects/dcim-ipam-automation/netbox-project/#step-4-create-group-for-vms","title":"Step 4 - Create group for VMs","text":"<p>Let's add your three managed nodes to a logical group within Netbox. In the Netbox UI, click on Virtualization, here you can find Clusters. Find an appropriate module to create a cluster and set the following module parameters:</p> Parameter Value name <code>Demo Tenant &lt;Initials&gt; VMs</code> site <code>rh_demo_environment</code> cluster_type <code>Amazon Web Services</code> group <code>EMEA</code> <p>Achieve the following tasks:</p> <ul> <li> Cluster created</li> </ul>"},{"location":"projects/dcim-ipam-automation/netbox-project/#step-5-create-vms","title":"Step 5 - Create VMs","text":"<p>A virtual machine (VM) represents a virtual compute instance hosted within a cluster. Each VM must be assigned to a site and/or cluster. Let's create multiple virtual machine objects, one for every host in your inventory group <code>web</code>. As we need additional information about our VMs (number of vCPU cores, memory, disk space), add a task which gathers facts about your managed nodes. Find the appropriate module to do this, Ansible documentation shows you how to do this, the keyword here is delegating facts.</p> <p>Once you gathered all facts about your managed nodes, add a task to create virtual machine objects in the Netbox with a loop, iterating over the <code>web</code> group of your inventory. Find the correct module, every VM object should use the following parameters:</p> Parameter Value Example (rendered to) name <code>\"{{ hostvars[item]['ansible_fqdn'] }}\"</code> node2.example.com site <code>rh_demo_environment</code> cluster <code>Demo Tenant &lt;Initials&gt; VMs</code> Demo Tenant TG VMs tenant <code>demo_tenant_&lt;initials&gt;</code> student2 platform <code>\"{{ hostvars[item]['ansible_distribution'] | lower }}_{{ hostvars[item]['ansible_distribution_major_version'] }}\"</code> Redhat 8 vcpus <code>\"{{ hostvars[item]['ansible_processor_vcpus'] }}\"</code> 2 memory <code>\"{{ hostvars[item]['ansible_memtotal_mb'] }}\"</code> 1024 disk <code>\"{{ hostvars[item]['ansible_devices']['nvme0n1']['size'] | split(' ') | first | int }}\"</code> 10 virtual_machine_role <code>application-server</code> status <code>Active</code> <p>Warning</p> <p>Again, replace <code>&lt;initials&gt;</code> with your own Initials.</p> <p>Achieve the following tasks:</p> <ul> <li> VM objects for all managed nodes created</li> </ul>"},{"location":"projects/linux-automation/grafana-project/","title":"Project - Linux automation","text":"<p>To further enhance your Ansible skills, let's deploy the monitoring tool Grafana to one of the nodes in the demo environment.</p> <p> </p>"},{"location":"projects/linux-automation/grafana-project/#objective","title":"Objective","text":"<p>Create an Ansible project from scratch and automate some basic linux configurations.</p>"},{"location":"projects/linux-automation/grafana-project/#guide","title":"Guide","text":""},{"location":"projects/linux-automation/grafana-project/#step-1-prepare-project","title":"Step 1 - Prepare project","text":"<p>Create a new project folder in your home directory:</p> <pre><code>[student@ansible-1 ~]$ mkdir grafana-deployment\n</code></pre> <p>Create an inventory file with a grafana group definition. You will deploy Grafana to one of the nodes in the lab environment. Copy the node2 configuration from the default inventory file to your grafana group. Create a small Ansible configuration file (<code>ansible.cfg</code>) and instruct Ansible to always use the inventory you just created.</p> <p>For example, you may check your inventory with the <code>ansible-inventory</code> CLI utility. In this case, the host has an alias of grafana-instance1 which is part of a group grafana:</p> <pre><code>[student@ansible-1 ~]$ ansible-inventory --graph --vars\n@all:\n  |--@ungrouped:\n  |--@grafana:\n  |  |--grafana-instance1\n  |  |  |--{ansible_host = node2.example.com}\n</code></pre> <p>Hint</p> <p>As you can see above, no inventory was provided in the CLI call (e.g. with <code>-i inventory</code>), but the correct inventory is used.</p> <p>Achieve the following tasks:</p> <ul> <li> Inventory file created</li> <li> Configuration file created which sets the correct inventory source</li> </ul>"},{"location":"projects/linux-automation/grafana-project/#step-2-install-grafana","title":"Step 2 - Install Grafana","text":"<p>The Grafana package comes from a dedicated repository, you'll need to enable it for the yum package manager on node2. Use the following file and copy it to <code>/etc/yum.repos.d/grafana.repo</code> with an Ansible task:</p> <pre><code>[grafana]\nname=grafana\nbaseurl=https://packages.grafana.com/oss/rpm\nrepo_gpgcheck=1\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.grafana.com/gpg.key\nsslverify=1\nsslcacert=/etc/pki/tls/certs/ca-bundle.crt\n</code></pre> <p>The next task should install the <code>grafana</code> package. Another task is needed to start (and enable) the <code>grafana-server</code> service.</p> <p>Achieve the following tasks:</p> <ul> <li> Running Grafana instance on node2</li> <li> Grafana service running and enabled at startup</li> </ul> <p>Ensure that Grafana is running with an ad hoc command:</p> <pre><code>[student@ansible-1 grafana-deployment]$ ansible grafana -a \"systemctl status grafana-server\"\nnode2 | CHANGED | rc=0 &gt;&gt;\n\u25cf grafana-server.service - Grafana instance\n   Loaded: loaded (/usr/lib/systemd/system/grafana-server.service; enabled; vendor preset: disabled)\n   Active: active (running) since Sun 2022-04-17 10:00:35 UTC; 2min 44s ago\n     Docs: http://docs.grafana.org\n Main PID: 20887 (grafana-server)\n    Tasks: 7 (limit: 4579)\n   Memory: 97.7M\n   CGroup: /system.slice/grafana-server.service\n           \u2514\u250020887 /usr/sbin/grafana-server --config=/etc/grafana/grafana.ini --pidfile=/var/run/grafana/grafana-server.pid --packaging=rpm cfg:default.paths.logs=/var/log/grafana cfg:default.paths.data=/var/lib/grafana cfg:default.paths.plugins=/var/lib/grafana/plugins cfg:default.paths.provisioning=/etc/grafana/provisioning\n</code></pre> <p>Accessing the Grafana UI from the browser currently fails with a timeout, use the public IP address of your node2 (the one from your inventory) and port 3000 (this is the default port for Grafana). We will fix this in the next step.</p>"},{"location":"projects/linux-automation/grafana-project/#step-3-configure-grafana","title":"Step 3 - Configure Grafana","text":"<p>Currently, you are not able to access the Grafana UI, using the public IP address of your node2 and the Grafana default port of 3000, you will get a timeout. The lab environment only allows access to Port 80 and 8080, yesterday you started an Apache webserver on these ports with Ansible. You'll have to configure Grafana to start on Port 8080 to able to access the UI.</p> <p>Warning</p> <p>There should be no running Apache webserver on node2, if otherwise, you'll need to stop httpd on node2! If the port is occupied, Grafana can not be started! You could (and should!) ensure a stopped Apache easily with an Ansible task...</p> <p>By default, Grafana uses a black background. You will adjust the Grafana configuration with Ansible to show the Grafana UI with white background. You will change the look from this...</p> <p></p> <p>...to this...</p> <p></p> <p>The configuration for Grafana is stored in <code>/etc/grafana/grafana.ini</code>. You need to adjust the theme configuration in the users section, as well as the http_port in the server section. Take a look at the Grafana documentation on how to change the parameters. Naturally, you should achieve this with Ansible! Find an appropriate module (there is more than one way to achieve the solution...) and adjust the Grafana configuration file.</p> <p>Tip</p> <p>Configuration changes require a service restart!</p> <p>After adjusting the configuration, try to access the Grafana UI again. Use the hostname (or public IP address) of your node2 and use Port 8080 this time.  </p> <p>Success</p> <p>Unfortunately, the UI currently can't be viewed directly in the Red Hat Demo environment! If you are in a local environment, you can use the default login credentials admin:admin, you can skip the password change request. You can check if the UI is available by using the curl request <code>curl -L node2:8080</code></p> Example output <pre><code>[student@ansible-1 ansible-files]$ curl -L node2:8080\n&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;script nonce=\"\"&gt;\n\n      !(function () {\n        if ('PerformanceLongTaskTiming' in window) {\n          var g = (window.__tti = { e: [] });\n          g.o = new PerformanceObserver(function (l) {\n            g.e = g.e.concat(l.getEntries());\n          });\n          g.o.observe({ entryTypes: ['longtask'] });\n        }\n      })();\n    &lt;/script&gt;\n    &lt;meta charset=\"utf-8\" /&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width\" /&gt;\n    &lt;meta name=\"theme-color\" content=\"#000\" /&gt;\n\n    &lt;title&gt;Grafana&lt;/title&gt;\n\n    &lt;base href=\"/\" /&gt;\n\n    &lt;link\n      rel=\"preload\"\n      href=\"public/fonts/roboto/RxZJdnzeo3R5zSexge8UUVtXRa8TVwTICgirnJhmVJw.woff2\"\n      as=\"font\"\n      crossorigin\n    /&gt;\n\n    &lt;link rel=\"icon\" type=\"image/png\" href=\"public/img/fav32.png\" /&gt;\n    &lt;link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"public/img/apple-touch-icon.png\" /&gt;\n    &lt;link rel=\"mask-icon\" href=\"public/img/grafana_mask_icon.svg\" color=\"#F05A28\" /&gt;\n    &lt;link rel=\"stylesheet\" href=\"public/build/grafana.dark.3b87c7ad03e52dfc5e30.css\" /&gt;\n\n    &lt;script nonce=\"\"&gt;\n      performance.mark('frontend_boot_css_time_seconds');\n    &lt;/script&gt;\n\n    &lt;meta name=\"apple-mobile-web-app-capable\" content=\"yes\" /&gt;\n    &lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt;\n    &lt;meta name=\"msapplication-TileColor\" content=\"#2b5797\" /&gt;\n    &lt;meta name=\"msapplication-config\" content=\"public/img/browserconfig.xml\" /&gt;\n  &lt;/head&gt;\n\n  &lt;body class=\"theme-light app-grafana\"&gt;\n    &lt;style&gt;\n      .preloader {\n        height: 100%;\n        flex-direction: column;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n      }\n  ...&lt;cut for readability&gt;...\n</code></pre> <p>You can use the following playbook the check the current theme setting, create a new file, paste to content and run it:</p> <pre><code>- name: Test Grafana theme setting\n  hosts: node2\n  tasks:\n    - name: Get Grafana UI content\n      ansible.builtin.uri:\n        url: http://node2:8080\n        return_content: true\n      register: grafana_ui_content\n\n    - name: Output current theme setting\n      ansible.builtin.debug:\n        msg: \"HTML body returns '{{ grafana_ui_content.content | replace('\\n', '') | regex_replace('^(.*body class=\\\\\\\")(.*)( app-grafana.*)', '\\\\2') }}' as the current color setting.\"\n</code></pre> <p>Achieve the following tasks:</p> <ul> <li> Accessible Grafana UI on port 8080</li> <li> Grafana UI in <code>light</code> theme</li> <li> Bonus: Can you manage to control the look of Grafana by just switching a variable?</li> </ul>"},{"location":"projects/linux-automation/grafana-project/#step-4-re-format-project-to-role-structure","title":"Step 4 - Re-format project to role structure","text":"<p>All Ansible projects should use the role structure, if your project does not already uses it, now is the time to rearrange your content. Create a <code>roles</code> folder and an appropriately named sub-folder for the grafana deployment with all necessary folder and files. Change your playbook to use your role, e.g.:</p> <pre><code>---\n# This is the main Playbook for the 'Grafana Deployment' Project\n\n- name: Deploy Grafana instance\n  hosts: grafana\n  roles:\n    - grafana\n</code></pre> <p>Make sure everything works by executing your playbook again, you should not see any changes, all tasks should return a green \"Ok\" status.</p> <p>Achieve the following tasks:</p> <ul> <li> Project uses Ansible role structure</li> <li> Playbook references role</li> </ul>"},{"location":"projects/linux-automation/grafana-project/#step-5-bonus-upload-project-to-github","title":"Step 5 - Bonus: Upload project to Github","text":"<p>Create a new project in your personal Github account and commit your Ansible project.</p>"},{"location":"projects/linux-automation/grafana-project/#step-6-bonus-run-your-project-within-aap","title":"Step 6 - Bonus: Run your project within AAP","text":"<p>Create a new project in AAP, reference your Grafana project from Github as the code source. Create a template and run your playbook.</p>"},{"location":"projects/network-automation/apic-project/","title":"Project - Network automation","text":"<p>Although the (historical) focus of Ansible was Linux automation, it is very strong with automating network as well. Ansible collections support a wide range of vendors, device types, and actions, so you can manage your entire network with a single automation tool. With Ansible, you can:</p> <ul> <li>Automate repetitive tasks to speed routine network changes and free up your time for more strategic work</li> <li>Leverage the same simple, powerful, and agent-less automation tool for network tasks that operations and development use</li> <li>Separate the data model (in a playbook or role) from the execution layer (via Ansible modules) to manage heterogeneous network devices</li> <li>Benefit from community and vendor-generated sample playbooks and roles to help accelerate network automation projects</li> <li>Communicate securely with network hardware over SSH or HTTPS</li> </ul>"},{"location":"projects/network-automation/apic-project/#objective","title":"Objective","text":"<p>Get to know network automation with Ansible. Network automation uses the basic Ansible concepts, but there are some differences in how the network modules work. Unlike most Ansible modules, network modules do not run on the managed nodes. From a user\u2019s point of view, network modules work like any other modules. They work with ad hoc commands, playbooks, and roles. Behind the scenes, however, network modules use a different methodology than the other (Linux/Unix and Windows) modules use. Ansible is written and executed in Python. Because the majority of network devices can not run Python, the Ansible network modules are executed on the Ansible control node.</p>"},{"location":"projects/network-automation/apic-project/#guide","title":"Guide","text":"<p>You will execute some automation tasks against Cisco ACI. The Cisco Application Centric Infrastructure allows application requirements to define the network. This architecture simplifies, optimizes, and accelerates the entire application deployment life cycle. The Application Policy Infrastructure Controller manages the scalable ACI multi-tenant fabric. The APIC provides a unified point of automation and management, policy programming, application deployment, and health monitoring for the fabric. The APIC, which is implemented as a replicated synchronized clustered controller, optimizes performance, supports any application anywhere, and provides unified operation of the physical and virtual infrastructure.</p> <p>The APIC enables network administrators to easily define the optimal network for applications. Data center operators can clearly see how applications consume network resources, easily isolate and troubleshoot application and infrastructure problems, and monitor and profile resource usage patterns.</p> <p>The Cisco Application Policy Infrastructure Controller API enables applications to directly connect with a secure, shared, high-performance resource pool that includes network, compute, and storage capabilities.</p>"},{"location":"projects/network-automation/apic-project/#step-1-prepare-project","title":"Step 1 - Prepare project","text":"<p>Create a new project folder in your home directory:</p> <pre><code>[student@ansible-1 ~]$ mkdir aci-automation\n</code></pre> <p>We will be using a Cisco ACI Sandbox available online.</p> <p></p> <p>Open a new browser tab and go to https://sandboxapicdc.cisco.com/#.</p> <p>Tip</p> <p>The credentials for accessing the Cisco Sandbox are shown below, you can copy the content by using the symbol on the right of the code block.</p> <p>Username:</p> <pre><code>admin\n</code></pre> <p>Password:</p> <pre><code>!v3G@!4@Y\n</code></pre> <p>Today, you might need additional Ansible modules. In the first part of the workshop, we only used a handful of modules which are all included in the <code>ansible-core</code> binary. With ansible-core only 69 of the most used modules are included:</p> <pre><code>[student@ansible-1 ~]$ ansible-doc -l\nadd_host               Add a host (and alternatively a group) to the ansible-playbook in-memory inventory  \napt                    Manages apt-packages  \napt_key                Add or remove an apt key  \napt_repository         Add and remove APT repositories  \nassemble               Assemble configuration files from fragments  \nassert                 Asserts given expressions are true  \nasync_status           Obtain status of asynchronous task  \nblockinfile            Insert/update/remove a text block surrounded by marker lines  \ncommand                Execute commands on targets  \ncopy                   Copy files to remote locations\n...\n</code></pre> <p>Additional modules are installed through collections, search the Collection Index in the Ansible documentation for a module or use the search field.</p> <p></p> <p>If, for example, you want to create an EC2 instance in AWS, you will need the module <code>amazon.aws.ec2_instance</code>. To get the module, you'll need the collection <code>aws</code> of the provider <code>amazon</code>. Download the collection with the <code>ansible-galaxy</code> utility:</p> <pre><code>[student@ansible-1 ~]$ ansible-galaxy collection install amazon.aws\nStarting galaxy collection install process\nProcess install dependency map\nStarting collection install process\nDownloading https://galaxy.ansible.com/download/amazon-aws-3.2.0.tar.gz to /home/student/.ansible/tmp/ansible-local-55382m3kkt4we/tmp7b2kxag4/amazon-aws-3.2.0-3itpmahr\nInstalling 'amazon.aws:3.2.0' to '/home/student/.ansible/collections/ansible_collections/amazon/aws'\namazon.aws:3.2.0 was installed successfully\n</code></pre> <p>Tip</p> <p>Well, you won't need the AWS collection, but automating the ACI with Ansible also requires additional modules, these are not included in the <code>ansible-core</code> binary and need to be installed with Ansible Galaxy.</p> <p>Achieve the following tasks:</p> <ul> <li> Find appropriate collection for Cisco ACI automation in the documentation</li> <li> Collection installed</li> </ul> <p>You can view the installed collections with this command:</p> <pre><code>[student@ansible-1 aci-automation]$ ansible-galaxy collection list\n# /home/student/.ansible/collections/ansible_collections\nCollection        Version\n----------------- -------\nansible.posix     1.4.0  \ncommunity.docker  2.7.0  \ncommunity.general 5.3.0\n</code></pre> Note <p>If you use the Ansible navigator (which utilizes an execution environment), the collection is available. The method for playbook execution is up to you, why not try it with both ways?!</p>"},{"location":"projects/network-automation/apic-project/#step-2-inventory-and-playbook","title":"Step 2 - Inventory and playbook","text":"<p>Within your newly created project folder, create an inventory file and a playbook file (the name of the files are up to you).</p> <pre><code>[student@ansible-1 aci-automation]$ touch inventory.ini\n[student@ansible-1 aci-automation]$ touch playbook.yml\n</code></pre> <p>Tip</p> <p>By default, Ansible will try to communicate via SSH. This will not work! You have to instruct Ansible to communicate with the APIC REST Interface, the ACI modules do not run on the network devices or controller, they need to run on the Ansible control node locally! Add the necessary parameters to your inventory file!</p> <p>Use the same credentials for API communication as for the login to the APIC UI. The API endpoint (host) for the ACI modules uses the URL of the sandbox, you won't need the prefix <code>https://</code>. The documentation provides an extensive Guide for ACI automation, which also describes how to setup communication with APIC.</p> <p>Testing the successful communication with the API could be done by querying ACI system information with the <code>aci_system</code> module. Create your playbook and add a task, utilizing this module. Fill all necessary parameter. Run your playbook, if it returns a green ok status, communication is established.</p> <p>For now, the gathered system information about the ACI system is not relevant for us, still, you could store the output in a variable and output it with an appropriate module, if you are curious.</p> <p>Achieve the following tasks:</p> <ul> <li> Inventory and playbook created</li> <li> Use variables where possible (and useful)</li> <li> Successful communication with APIC established</li> </ul> <p>You may encounter the following error messages:</p> <p>Failure</p> <p>Expect an error message complaining about certification verification:</p> <pre><code>Connection failed for https://sandboxapicdc.cisco.com/api/aaaLogin.json. Request failed: &lt;urlopen error [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1131)&gt;\n</code></pre> <p>If you see an error message like above, you can disable certificate validation for your task:</p> <pre><code>validate_certs: false\n</code></pre> <p>For a production environment this is obviously not recommended!</p> <p>Failure</p> <p>If you see one of the following error messages, ensure that the Sandbox is available:</p> <pre><code>Connection failed for https://sandboxapicdc.cisco.com/api/aaaLogin.json. Connection failure: The read operation timed out\n</code></pre> <pre><code>Authentication failed: -1 Unable to parse output as JSON, see 'raw' output. Expecting value: line 1 column 1 (char 0)\", \"raw\": \"&lt;html&gt;\\r\\n&lt;head&gt;&lt;title&gt;502 Bad Gateway&lt;/title&gt;&lt;/head&gt;\\r\\n&lt;body bgcolor=\\\"white\\\"&gt;\\r\\n&lt;center&gt;&lt;h1&gt;502 Bad Gateway&lt;/h1&gt;&lt;/center&gt;\\r\\n&lt;hr&gt;&lt;center&gt;nginx/1.13.12&lt;/center&gt;\\r\\n&lt;/body&gt;\\r\\n&lt;/html&gt;\\r\\n\n</code></pre> <p>Try to reload the APIC browser tab.</p> <p>In case of an unavailable APIC sandbox, re-run your playbook when it comes back online.  </p>"},{"location":"projects/network-automation/apic-project/#step-3-create-a-new-tenant","title":"Step 3 - Create a new tenant","text":"<p>The APIC manages the scalable ACI multi-tenant fabric. A multi-tenant environment or multi-tenancy data centres handle segregation of traffic between multiple tenants and ensure privacy and security between tenant data.</p> <p>The goal is to create a new tenant within the APIC controller with Ansible. The tenant should have a recognizable name e.g. <code>demo-tenant-&lt;initials&gt;</code>. Add the tenant description <code>Workshop tenant</code>.</p> <p></p> <p>Observe the tenant and it's annotation in the APIC UI.</p> <p>Achieve the following tasks:</p> <ul> <li> Tenant created</li> <li> Inspected tenant in the UI</li> </ul>"},{"location":"projects/network-automation/apic-project/#step-4-ap-creation-and-epgs","title":"Step 4 - AP creation and EPGs","text":"<p>Now, that we have our own custom tenant, lets fill it with content. Create an Application profile and add multiple end point groups. Application profiles are container for the grouping of endpoint groups. For example, an AP could group a web server with the backend database, with storage, and so on.</p> <p>Create an Application profile with the following attributes:</p> Parameter Value AP name <code>workshop</code> AP description <code>Workshop AP</code> Monitoring Policy <code>default</code> <p>Ensure that your AP is created for your own tenant!</p> <p>Let's create three EPGs for our Application profile, use a single task by creating them in a loop. The EPGs should have the following attributes:</p> Loop item EPG name EPG description 1 <code>web</code> <code>Web EPG</code> 2 <code>app</code> <code>APP EPG</code> 3 <code>db</code> <code>DB EPG</code> <p>Setting the required attributes requires looping over a list of hashes. All EPGs should have the <code>default</code> monitoring policy attached.</p> <p>Observe the tenant in the APIC UI.</p> <p>Achieve the following tasks:</p> <ul> <li> Application profile created</li> <li> EPGs created</li> </ul> <p>Note</p> <p>No communication between the different EPGs is established yet, this would be achieved with contracts. By now, you are experienced enough with creating objects in ACI with Ansible, let's skip the contracts creation.</p>"},{"location":"projects/network-automation/apic-project/#step-5-roles-and-encryption","title":"Step 5 - Roles and encryption","text":"<p>Now that you can execute automated tasks against the ACI, let's re-format the project and use some Ansible best-practices. All Ansible projects should use the role structure, if your project does not already uses it, now is the time to rearrange your content. Create a <code>roles</code> folder and an appropriately named sub-folder for the tenant creation with all necessary folder and files.  </p> <p>Your tasks using the Ansible ACI module(s) require username and password, at least the password should be encrypted. Ansible Vault encrypts variables and files so you can protect sensitive content rather than leaving it visible as plaintext in playbooks or roles, take a look at the Ansible Vault documentation for further information. Encrypt the APIC credentials and re-run your playbook.</p> <p>Tip</p> <p>Remember the necessary additional cli parameter when executing a playbook which references encrypted content.</p> <p>Achieve the following tasks:</p> <ul> <li> Project uses Ansible role structure</li> <li> APIC credentials are vault-encrypted</li> <li> Playbook references role, tasks are executed</li> </ul>"},{"location":"projects/network-automation/apic-project/#step-6-use-filters-to-manipulate-data","title":"Step 6 - Use filters to manipulate data","text":"<p>Filters let you transform JSON data into YAML data, split a URL to extract the hostname, get the SHA1 hash of a string, add or multiply integers, and much more. You can use the Ansible-specific filters documented here to manipulate your data, or use any of the standard filters shipped with Jinja2.</p> <p>Create a new role which utilizes an Ansible ACI module that can manage contract resources (vz:BrCP). Get all contracts of the common tenant and output a list with only the contract names.</p> <p></p> <p>The common tenant has at least one contract (default).</p> <p>Dealing with network devices often means dealing with large JSON objects and you have to filter the output to your needs. Browse the Ansible filter documentation for a suitable filter.</p> <p>The Ansible module you will be using returns a JSON output like the following:</p> <pre><code>  \"changed\": false,\n  \"current\": [\n    {\n      \"fvTenant\": {\n        \"attributes\": {\n          \"annotation\": \"\",\n          \"childAction\": \"\",\n          \"descr\": \"\",\n          \"dn\": \"uni/tn-common\",\n          \"extMngdBy\": \"\",\n          \"lcOwn\": \"local\",\n          \"modTs\": \"2022-04-16T13:54:30.664+00:00\",\n          \"monPolDn\": \"uni/tn-common/monepg-default\",\n          \"name\": \"common\",\n          \"nameAlias\": \"\",\n          \"ownerKey\": \"\",\n          \"ownerTag\": \"\",\n          \"status\": \"\",\n          \"uid\": \"0\",\n          \"userdom\": \"all\"\n        },\n        \"children\": [\n            {\n              \"vzBrCP\": {\n                \"attributes\": {\n                  \"accessPrivilege\": \"USER\",\n                  \"annotation\": \"\",\n                  \"childAction\": \"\",\n                  \"configIssues\": \"\",\n                  \"descr\": \"\",\n                  \"extMngdBy\": \"\",\n                  \"intent\": \"install\",\n                  \"lcOwn\": \"local\",\n                  \"modTs\": \"2022-04-16T13:54:30.664+00:00\",\n                  \"monPolDn\": \"uni/tn-common/monepg-default\",\n                  \"name\": \"default\",\n                  \"nameAlias\": \"\",\n                  \"ownerKey\": \"\",\n                  \"ownerTag\": \"\",\n                  \"prio\": \"unspecified\",\n                  \"reevaluateAll\": \"no\",\n                  \"rn\": \"brc-default\",\n                  \"scope\": \"context\",\n                  \"status\": \"\",\n                  \"targetDscp\": \"unspecified\",\n                  \"uid\": \"0\",\n                  \"userdom\": \"all\"\n                },\n                \"children\": [\n                  {\n                    \"vzSubj\": {\n                      \"attributes\": {\n                        \"accessPrivilege\": \"USER\",\n                        \"annotation\": \"\",\n                        \"childAction\": \"\",\n                        \"configIssues\": \"\",\n                        \"consMatchT\": \"AtleastOne\",\n                        \"descr\": \"\",\n                        \"extMngdBy\": \"\",\n                        \"lcOwn\": \"local\",\n                        \"modTs\": \"2022-04-16T13:54:30.664+00:00\",\n                        \"monPolDn\": \"uni/tn-common/monepg-default\",\n                        \"name\": \"default\",\n                        \"nameAlias\": \"\",\n                        \"prio\": \"unspecified\",\n                        \"provMatchT\": \"AtleastOne\",\n                        \"revFltPorts\": \"yes\",\n                        \"rn\": \"subj-default\",\n                        \"status\": \"\",\n                        \"targetDscp\": \"unspecified\",\n                        \"uid\": \"0\",\n                        \"userdom\": \"all\"\n                      },\n                      \"children\": [\n                        {\n                          \"vzRsSubjFiltAtt\": {\n                            \"attributes\": {\n                              \"accessPrivilege\": \"USER\",\n                              \"action\": \"permit\",\n                              \"annotation\": \"\",\n                              \"childAction\": \"\",\n                              \"directives\": \"\",\n                              \"extMngdBy\": \"\",\n                              \"forceResolve\": \"yes\",\n                              \"lcOwn\": \"local\",\n                              \"modTs\": \"2022-04-16T13:54:30.664+00:00\",\n                              \"monPolDn\": \"uni/tn-common/monepg-default\",\n                              \"priorityOverride\": \"default\",\n                              \"rType\": \"mo\",\n                              \"rn\": \"rssubjFiltAtt-default\",\n                              \"state\": \"formed\",\n                              \"stateQual\": \"none\",\n                              \"status\": \"\",\n                              \"tCl\": \"vzFilter\",\n                              \"tContextDn\": \"\",\n                              \"tDn\": \"uni/tn-common/flt-default\",\n                              \"tRn\": \"flt-default\",\n                              \"tType\": \"name\",\n                              \"tnVzFilterName\": \"default\",\n                              \"uid\": \"0\",\n                              \"userdom\": \"all\"\n                            }\n                          }\n                        }\n                      ]\n                    }\n                  }\n                ]\n              }\n            }\n          ]\n        }\n      }\n    ],\n    \"failed\": false\n  }\n}\n</code></pre> <p>The highlighted lines show the list of contracts and the name of the contract-element. You need to traverse the JSON object until you reach the key you want to get. In JSON, list-objects are encapsulated with square brackets (start with [ and end with ]), dictionary objects with curly brackets (start with { and end with }).  </p> <p>Observing the above output, you can see that multiple list objects are within the complete JSON object. The value of the key <code>current</code> is a list, every list item of this key is a tenant (with multiple key-value pairs which can also be dictionaries or lists).</p> <p>If you filter for a single tenant (by providing the tenant name) when using the module, the list <code>current</code> only has one element. Lists (in Python, which Ansible is based on) start at element 0, the second list element is 1 and so on.</p> <p>The resulting output in your playbook-run should look something like this (considering that the common tenant only has one contract):</p> <pre><code>TASK [aci-contract : Output list of contract names of Tenant 'common'] ********\nok: [demo-aci-host] =&gt; {\n    \"msg\": [\n        \"default\"\n    ]\n}\n</code></pre> <p>Tip</p> <p>There are multiple ways to achieve the desired solution, try around! Dealing with large JSON objects and outputting it to stdout may result in not being able to scroll back far enough to see the start of your task or playbook. You can adjust the VScode configuration yourself.</p> <p>Achieve the following tasks:</p> <ul> <li> New role for contract handling created</li> <li> Playbook runs both roles</li> <li> Playbook outputs list of all contracts for common tenant</li> </ul> If you struggle to find a solution, here are some hints. (Try without them first!) <p>The following tips may help you to develop a solution:</p> <ul> <li>Use the <code>cisco.aci.aci_contract</code> module.</li> <li>Define the tenant <code>common</code> in the module, otherwise you will get all contracts of all users, which is harder to parse.  </li> <li>Use <code>state: query</code> for listing all contract objects.  </li> <li>Store the module output in a variable (register).  </li> <li>Use the <code>json_query</code> filter. The filter is part of the <code>community.general</code> collection.  </li> <li>You need to install a Python package for the filter, run <code>pip3.9 install jmespath</code> (if your Ansible uses Python3.9, run <code>ansible --version</code> to find out)</li> <li>Traversing the JSON object can be achieved by <code>current[0].fvTenant.children...</code> </li> <li>Output to stdout can be achieved with the debug module.</li> </ul>"}]}